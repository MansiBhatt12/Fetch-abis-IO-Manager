0,NOTOK,Invalid Address format
1,OK,"[{'SourceCode': '// File: contracts/interfaces/IUniswapV2Pair.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\n// File: contracts/interfaces/IUniswapV2ERC20.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IUniswapV2ERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n}\r\n\r\n// File: contracts/libraries/SafeMath.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\r\n\r\nlibrary SafeMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, \'ds-math-add-overflow\');\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, \'ds-math-sub-underflow\');\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \'ds-math-mul-overflow\');\r\n    }\r\n}\r\n\r\n// File: contracts/UniswapV2ERC20.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n\r\n\r\ncontract UniswapV2ERC20 is IUniswapV2ERC20 {\r\n    using SafeMath for uint;\r\n\r\n    string public constant name = \'Uniswap V2\';\r\n    string public constant symbol = \'UNI-V2\';\r\n    uint8 public constant decimals = 18;\r\n    uint  public totalSupply;\r\n    mapping(address => uint) public balanceOf;\r\n    mapping(address => mapping(address => uint)) public allowance;\r\n\r\n    bytes32 public DOMAIN_SEPARATOR;\r\n    // keccak256(""Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"");\r\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\r\n    mapping(address => uint) public nonces;\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    constructor() public {\r\n        uint chainId;\r\n        assembly {\r\n            chainId := chainid\r\n        }\r\n        DOMAIN_SEPARATOR = keccak256(\r\n            abi.encode(\r\n                keccak256(\'EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\'),\r\n                keccak256(bytes(name)),\r\n                keccak256(bytes(\'1\')),\r\n                chainId,\r\n                address(this)\r\n            )\r\n        );\r\n    }\r\n\r\n    function _mint(address to, uint value) internal {\r\n        totalSupply = totalSupply.add(value);\r\n        balanceOf[to] = balanceOf[to].add(value);\r\n        emit Transfer(address(0), to, value);\r\n    }\r\n\r\n    function _burn(address from, uint value) internal {\r\n        balanceOf[from] = balanceOf[from].sub(value);\r\n        totalSupply = totalSupply.sub(value);\r\n        emit Transfer(from, address(0), value);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint value) private {\r\n        allowance[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    function _transfer(address from, address to, uint value) private {\r\n        balanceOf[from] = balanceOf[from].sub(value);\r\n        balanceOf[to] = balanceOf[to].add(value);\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    function approve(address spender, uint value) external returns (bool) {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address to, uint value) external returns (bool) {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint value) external returns (bool) {\r\n        if (allowance[from][msg.sender] != uint(-1)) {\r\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\r\n        }\r\n        _transfer(from, to, value);\r\n        return true;\r\n    }\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\r\n        require(deadline >= block.timestamp, \'UniswapV2: EXPIRED\');\r\n        bytes32 digest = keccak256(\r\n            abi.encodePacked(\r\n                \'\\x19\\x01\',\r\n                DOMAIN_SEPARATOR,\r\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\r\n            )\r\n        );\r\n        address recoveredAddress = ecrecover(digest, v, r, s);\r\n        require(recoveredAddress != address(0) && recoveredAddress == owner, \'UniswapV2: INVALID_SIGNATURE\');\r\n        _approve(owner, spender, value);\r\n    }\r\n}\r\n\r\n// File: contracts/libraries/Math.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n// a library for performing various math operations\r\n\r\nlibrary Math {\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        z = x < y ? x : y;\r\n    }\r\n\r\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\r\n    function sqrt(uint y) internal pure returns (uint z) {\r\n        if (y > 3) {\r\n            z = y;\r\n            uint x = y / 2 + 1;\r\n            while (x < z) {\r\n                z = x;\r\n                x = (y / x + x) / 2;\r\n            }\r\n        } else if (y != 0) {\r\n            z = 1;\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/libraries/UQ112x112.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\r\n\r\n// range: [0, 2**112 - 1]\r\n// resolution: 1 / 2**112\r\n\r\nlibrary UQ112x112 {\r\n    uint224 constant Q112 = 2**112;\r\n\r\n    // encode a uint112 as a UQ112x112\r\n    function encode(uint112 y) internal pure returns (uint224 z) {\r\n        z = uint224(y) * Q112; // never overflows\r\n    }\r\n\r\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\r\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\r\n        z = x / uint224(y);\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/IERC20.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n}\r\n\r\n// File: contracts/interfaces/IUniswapV2Factory.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\n// File: contracts/interfaces/IUniswapV2Callee.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IUniswapV2Callee {\r\n    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;\r\n}\r\n\r\n// File: contracts/UniswapV2Pair.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract UniswapV2Pair is IUniswapV2Pair, UniswapV2ERC20 {\r\n    using SafeMath  for uint;\r\n    using UQ112x112 for uint224;\r\n\r\n    uint public constant MINIMUM_LIQUIDITY = 10**3;\r\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes(\'transfer(address,uint256)\')));\r\n\r\n    address public factory;\r\n    address public token0;\r\n    address public token1;\r\n\r\n    uint112 private reserve0;           // uses single storage slot, accessible via getReserves\r\n    uint112 private reserve1;           // uses single storage slot, accessible via getReserves\r\n    uint32  private blockTimestampLast; // uses single storage slot, accessible via getReserves\r\n\r\n    uint public price0CumulativeLast;\r\n    uint public price1CumulativeLast;\r\n    uint public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event\r\n\r\n    uint private unlocked = 1;\r\n    modifier lock() {\r\n        require(unlocked == 1, \'UniswapV2: LOCKED\');\r\n        unlocked = 0;\r\n        _;\r\n        unlocked = 1;\r\n    }\r\n\r\n    function getReserves() public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {\r\n        _reserve0 = reserve0;\r\n        _reserve1 = reserve1;\r\n        _blockTimestampLast = blockTimestampLast;\r\n    }\r\n\r\n    function _safeTransfer(address token, address to, uint value) private {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \'UniswapV2: TRANSFER_FAILED\');\r\n    }\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    constructor() public {\r\n        factory = msg.sender;\r\n    }\r\n\r\n    // called once by the factory at time of deployment\r\n    function initialize(address _token0, address _token1) external {\r\n        require(msg.sender == factory, \'UniswapV2: FORBIDDEN\'); // sufficient check\r\n        token0 = _token0;\r\n        token1 = _token1;\r\n    }\r\n\r\n    // update reserves and, on the first call per block, price accumulators\r\n    function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {\r\n        require(balance0 <= uint112(-1) && balance1 <= uint112(-1), \'UniswapV2: OVERFLOW\');\r\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\r\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\r\n        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\r\n            // * never overflows, and + overflow is desired\r\n            price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;\r\n            price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;\r\n        }\r\n        reserve0 = uint112(balance0);\r\n        reserve1 = uint112(balance1);\r\n        blockTimestampLast = blockTimestamp;\r\n        emit Sync(reserve0, reserve1);\r\n    }\r\n\r\n    // if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)\r\n    function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {\r\n        address feeTo = IUniswapV2Factory(factory).feeTo();\r\n        feeOn = feeTo != address(0);\r\n        uint _kLast = kLast; // gas savings\r\n        if (feeOn) {\r\n            if (_kLast != 0) {\r\n                uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));\r\n                uint rootKLast = Math.sqrt(_kLast);\r\n                if (rootK > rootKLast) {\r\n                    uint numerator = totalSupply.mul(rootK.sub(rootKLast));\r\n                    uint denominator = rootK.mul(5).add(rootKLast);\r\n                    uint liquidity = numerator / denominator;\r\n                    if (liquidity > 0) _mint(feeTo, liquidity);\r\n                }\r\n            }\r\n        } else if (_kLast != 0) {\r\n            kLast = 0;\r\n        }\r\n    }\r\n\r\n    // this low-level function should be called from a contract which performs important safety checks\r\n    function mint(address to) external lock returns (uint liquidity) {\r\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\r\n        uint balance0 = IERC20(token0).balanceOf(address(this));\r\n        uint balance1 = IERC20(token1).balanceOf(address(this));\r\n        uint amount0 = balance0.sub(_reserve0);\r\n        uint amount1 = balance1.sub(_reserve1);\r\n\r\n        bool feeOn = _mintFee(_reserve0, _reserve1);\r\n        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\r\n        if (_totalSupply == 0) {\r\n            liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);\r\n           _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\r\n        } else {\r\n            liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);\r\n        }\r\n        require(liquidity > 0, \'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED\');\r\n        _mint(to, liquidity);\r\n\r\n        _update(balance0, balance1, _reserve0, _reserve1);\r\n        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\r\n        emit Mint(msg.sender, amount0, amount1);\r\n    }\r\n\r\n    // this low-level function should be called from a contract which performs important safety checks\r\n    function burn(address to) external lock returns (uint amount0, uint amount1) {\r\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\r\n        address _token0 = token0;                                // gas savings\r\n        address _token1 = token1;                                // gas savings\r\n        uint balance0 = IERC20(_token0).balanceOf(address(this));\r\n        uint balance1 = IERC20(_token1).balanceOf(address(this));\r\n        uint liquidity = balanceOf[address(this)];\r\n\r\n        bool feeOn = _mintFee(_reserve0, _reserve1);\r\n        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\r\n        amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution\r\n        amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution\r\n        require(amount0 > 0 && amount1 > 0, \'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED\');\r\n        _burn(address(this), liquidity);\r\n        _safeTransfer(_token0, to, amount0);\r\n        _safeTransfer(_token1, to, amount1);\r\n        balance0 = IERC20(_token0).balanceOf(address(this));\r\n        balance1 = IERC20(_token1).balanceOf(address(this));\r\n\r\n        _update(balance0, balance1, _reserve0, _reserve1);\r\n        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\r\n        emit Burn(msg.sender, amount0, amount1, to);\r\n    }\r\n\r\n    // this low-level function should be called from a contract which performs important safety checks\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock {\r\n        require(amount0Out > 0 || amount1Out > 0, \'UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT\');\r\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\r\n        require(amount0Out < _reserve0 && amount1Out < _reserve1, \'UniswapV2: INSUFFICIENT_LIQUIDITY\');\r\n\r\n        uint balance0;\r\n        uint balance1;\r\n        { // scope for _token{0,1}, avoids stack too deep errors\r\n        address _token0 = token0;\r\n        address _token1 = token1;\r\n        require(to != _token0 && to != _token1, \'UniswapV2: INVALID_TO\');\r\n        if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\r\n        if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\r\n        if (data.length > 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);\r\n        balance0 = IERC20(_token0).balanceOf(address(this));\r\n        balance1 = IERC20(_token1).balanceOf(address(this));\r\n        }\r\n        uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\r\n        uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\r\n        require(amount0In > 0 || amount1In > 0, \'UniswapV2: INSUFFICIENT_INPUT_AMOUNT\');\r\n        { // scope for reserve{0,1}Adjusted, avoids stack too deep errors\r\n        uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));\r\n        uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));\r\n        require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), \'UniswapV2: K\');\r\n        }\r\n\r\n        _update(balance0, balance1, _reserve0, _reserve1);\r\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\r\n    }\r\n\r\n    // force balances to match reserves\r\n    function skim(address to) external lock {\r\n        address _token0 = token0; // gas savings\r\n        address _token1 = token1; // gas savings\r\n        _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0));\r\n        _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));\r\n    }\r\n\r\n    // force reserves to match balances\r\n    function sync() external lock {\r\n        _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);\r\n    }\r\n}', 'ABI': '[{""inputs"":[],""payable"":false,""stateMutability"":""nonpayable"",""type"":""constructor""},{""anonymous"":false,""inputs"":[{""indexed"":true,""internalType"":""address"",""name"":""owner"",""type"":""address""},{""indexed"":true,""internalType"":""address"",""name"":""spender"",""type"":""address""},{""indexed"":false,""internalType"":""uint256"",""name"":""value"",""type"":""uint256""}],""name"":""Approval"",""type"":""event""},{""anonymous"":false,""inputs"":[{""indexed"":true,""internalType"":""address"",""name"":""sender"",""type"":""address""},{""indexed"":false,""internalType"":""uint256"",""name"":""amount0"",""type"":""uint256""},{""indexed"":false,""internalType"":""uint256"",""name"":""amount1"",""type"":""uint256""},{""indexed"":true,""internalType"":""address"",""name"":""to"",""type"":""address""}],""name"":""Burn"",""type"":""event""},{""anonymous"":false,""inputs"":[{""indexed"":true,""internalType"":""address"",""name"":""sender"",""type"":""address""},{""indexed"":false,""internalType"":""uint256"",""name"":""amount0"",""type"":""uint256""},{""indexed"":false,""internalType"":""uint256"",""name"":""amount1"",""type"":""uint256""}],""name"":""Mint"",""type"":""event""},{""anonymous"":false,""inputs"":[{""indexed"":true,""internalType"":""address"",""name"":""sender"",""type"":""address""},{""indexed"":false,""internalType"":""uint256"",""name"":""amount0In"",""type"":""uint256""},{""indexed"":false,""internalType"":""uint256"",""name"":""amount1In"",""type"":""uint256""},{""indexed"":false,""internalType"":""uint256"",""name"":""amount0Out"",""type"":""uint256""},{""indexed"":false,""internalType"":""uint256"",""name"":""amount1Out"",""type"":""uint256""},{""indexed"":true,""internalType"":""address"",""name"":""to"",""type"":""address""}],""name"":""Swap"",""type"":""event""},{""anonymous"":false,""inputs"":[{""indexed"":false,""internalType"":""uint112"",""name"":""reserve0"",""type"":""uint112""},{""indexed"":false,""internalType"":""uint112"",""name"":""reserve1"",""type"":""uint112""}],""name"":""Sync"",""type"":""event""},{""anonymous"":false,""inputs"":[{""indexed"":true,""internalType"":""address"",""name"":""from"",""type"":""address""},{""indexed"":true,""internalType"":""address"",""name"":""to"",""type"":""address""},{""indexed"":false,""internalType"":""uint256"",""name"":""value"",""type"":""uint256""}],""name"":""Transfer"",""type"":""event""},{""constant"":true,""inputs"":[],""name"":""DOMAIN_SEPARATOR"",""outputs"":[{""internalType"":""bytes32"",""name"":"""",""type"":""bytes32""}],""payable"":false,""stateMutability"":""view"",""type"":""function""},{""constant"":true,""inputs"":[],""name"":""MINIMUM_LIQUIDITY"",""outputs"":[{""internalType"":""uint256"",""name"":"""",""type"":""uint256""}],""payable"":false,""stateMutability"":""view"",""type"":""function""},{""constant"":true,""inputs"":[],""name"":""PERMIT_TYPEHASH"",""outputs"":[{""internalType"":""bytes32"",""name"":"""",""type"":""bytes32""}],""payable"":false,""stateMutability"":""view"",""type"":""function""},{""constant"":true,""inputs"":[{""internalType"":""address"",""name"":"""",""type"":""address""},{""internalType"":""address"",""name"":"""",""type"":""address""}],""name"":""allowance"",""outputs"":[{""internalType"":""uint256"",""name"":"""",""type"":""uint256""}],""payable"":false,""stateMutability"":""view"",""type"":""function""},{""constant"":false,""inputs"":[{""internalType"":""address"",""name"":""spender"",""type"":""address""},{""internalType"":""uint256"",""name"":""value"",""type"":""uint256""}],""name"":""approve"",""outputs"":[{""internalType"":""bool"",""name"":"""",""type"":""bool""}],""payable"":false,""stateMutability"":""nonpayable"",""type"":""function""},{""constant"":true,""inputs"":[{""internalType"":""address"",""name"":"""",""type"":""address""}],""name"":""balanceOf"",""outputs"":[{""internalType"":""uint256"",""name"":"""",""type"":""uint256""}],""payable"":false,""stateMutability"":""view"",""type"":""function""},{""constant"":false,""inputs"":[{""internalType"":""address"",""name"":""to"",""type"":""address""}],""name"":""burn"",""outputs"":[{""internalType"":""uint256"",""name"":""amount0"",""type"":""uint256""},{""internalType"":""uint256"",""name"":""amount1"",""type"":""uint256""}],""payable"":false,""stateMutability"":""nonpayable"",""type"":""function""},{""constant"":true,""inputs"":[],""name"":""decimals"",""outputs"":[{""internalType"":""uint8"",""name"":"""",""type"":""uint8""}],""payable"":false,""stateMutability"":""view"",""type"":""function""},{""constant"":true,""inputs"":[],""name"":""factory"",""outputs"":[{""internalType"":""address"",""name"":"""",""type"":""address""}],""payable"":false,""stateMutability"":""view"",""type"":""function""},{""constant"":true,""inputs"":[],""name"":""getReserves"",""outputs"":[{""internalType"":""uint112"",""name"":""_reserve0"",""type"":""uint112""},{""internalType"":""uint112"",""name"":""_reserve1"",""type"":""uint112""},{""internalType"":""uint32"",""name"":""_blockTimestampLast"",""type"":""uint32""}],""payable"":false,""stateMutability"":""view"",""type"":""function""},{""constant"":false,""inputs"":[{""internalType"":""address"",""name"":""_token0"",""type"":""address""},{""internalType"":""address"",""name"":""_token1"",""type"":""address""}],""name"":""initialize"",""outputs"":[],""payable"":false,""stateMutability"":""nonpayable"",""type"":""function""},{""constant"":true,""inputs"":[],""name"":""kLast"",""outputs"":[{""internalType"":""uint256"",""name"":"""",""type"":""uint256""}],""payable"":false,""stateMutability"":""view"",""type"":""function""},{""constant"":false,""inputs"":[{""internalType"":""address"",""name"":""to"",""type"":""address""}],""name"":""mint"",""outputs"":[{""internalType"":""uint256"",""name"":""liquidity"",""type"":""uint256""}],""payable"":false,""stateMutability"":""nonpayable"",""type"":""function""},{""constant"":true,""inputs"":[],""name"":""name"",""outputs"":[{""internalType"":""string"",""name"":"""",""type"":""string""}],""payable"":false,""stateMutability"":""view"",""type"":""function""},{""constant"":true,""inputs"":[{""internalType"":""address"",""name"":"""",""type"":""address""}],""name"":""nonces"",""outputs"":[{""internalType"":""uint256"",""name"":"""",""type"":""uint256""}],""payable"":false,""stateMutability"":""view"",""type"":""function""},{""constant"":false,""inputs"":[{""internalType"":""address"",""name"":""owner"",""type"":""address""},{""internalType"":""address"",""name"":""spender"",""type"":""address""},{""internalType"":""uint256"",""name"":""value"",""type"":""uint256""},{""internalType"":""uint256"",""name"":""deadline"",""type"":""uint256""},{""internalType"":""uint8"",""name"":""v"",""type"":""uint8""},{""internalType"":""bytes32"",""name"":""r"",""type"":""bytes32""},{""internalType"":""bytes32"",""name"":""s"",""type"":""bytes32""}],""name"":""permit"",""outputs"":[],""payable"":false,""stateMutability"":""nonpayable"",""type"":""function""},{""constant"":true,""inputs"":[],""name"":""price0CumulativeLast"",""outputs"":[{""internalType"":""uint256"",""name"":"""",""type"":""uint256""}],""payable"":false,""stateMutability"":""view"",""type"":""function""},{""constant"":true,""inputs"":[],""name"":""price1CumulativeLast"",""outputs"":[{""internalType"":""uint256"",""name"":"""",""type"":""uint256""}],""payable"":false,""stateMutability"":""view"",""type"":""function""},{""constant"":false,""inputs"":[{""internalType"":""address"",""name"":""to"",""type"":""address""}],""name"":""skim"",""outputs"":[],""payable"":false,""stateMutability"":""nonpayable"",""type"":""function""},{""constant"":false,""inputs"":[{""internalType"":""uint256"",""name"":""amount0Out"",""type"":""uint256""},{""internalType"":""uint256"",""name"":""amount1Out"",""type"":""uint256""},{""internalType"":""address"",""name"":""to"",""type"":""address""},{""internalType"":""bytes"",""name"":""data"",""type"":""bytes""}],""name"":""swap"",""outputs"":[],""payable"":false,""stateMutability"":""nonpayable"",""type"":""function""},{""constant"":true,""inputs"":[],""name"":""symbol"",""outputs"":[{""internalType"":""string"",""name"":"""",""type"":""string""}],""payable"":false,""stateMutability"":""view"",""type"":""function""},{""constant"":false,""inputs"":[],""name"":""sync"",""outputs"":[],""payable"":false,""stateMutability"":""nonpayable"",""type"":""function""},{""constant"":true,""inputs"":[],""name"":""token0"",""outputs"":[{""internalType"":""address"",""name"":"""",""type"":""address""}],""payable"":false,""stateMutability"":""view"",""type"":""function""},{""constant"":true,""inputs"":[],""name"":""token1"",""outputs"":[{""internalType"":""address"",""name"":"""",""type"":""address""}],""payable"":false,""stateMutability"":""view"",""type"":""function""},{""constant"":true,""inputs"":[],""name"":""totalSupply"",""outputs"":[{""internalType"":""uint256"",""name"":"""",""type"":""uint256""}],""payable"":false,""stateMutability"":""view"",""type"":""function""},{""constant"":false,""inputs"":[{""internalType"":""address"",""name"":""to"",""type"":""address""},{""internalType"":""uint256"",""name"":""value"",""type"":""uint256""}],""name"":""transfer"",""outputs"":[{""internalType"":""bool"",""name"":"""",""type"":""bool""}],""payable"":false,""stateMutability"":""nonpayable"",""type"":""function""},{""constant"":false,""inputs"":[{""internalType"":""address"",""name"":""from"",""type"":""address""},{""internalType"":""address"",""name"":""to"",""type"":""address""},{""internalType"":""uint256"",""name"":""value"",""type"":""uint256""}],""name"":""transferFrom"",""outputs"":[{""internalType"":""bool"",""name"":"""",""type"":""bool""}],""payable"":false,""stateMutability"":""nonpayable"",""type"":""function""}]', 'ContractName': 'UniswapV2Pair', 'CompilerVersion': 'v0.5.16+commit.9c3226ce', 'OptimizationUsed': '1', 'Runs': '999999', 'ConstructorArguments': '', 'EVMVersion': 'Default', 'Library': '', 'LicenseType': 'GNU GPLv3', 'Proxy': '0', 'Implementation': '', 'SwarmSource': 'bzzr://7dca18479e58487606bf70c79e44d8dee62353c9ee6d01f9a9d70885b8765f22'}]"
1,OK,"[{'SourceCode': '{{\r\n  ""language"": ""Solidity"",\r\n  ""sources"": {\r\n    ""/home/nicklatkovich/pixelplex/riochain/om-token-v2/contracts/OMTokenV2.sol"": {\r\n      ""content"": ""// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\n\\nimport \\""openzeppelin-solidity/contracts/token/ERC20/ERC20Capped.sol\\"";\\nimport \\""openzeppelin-solidity/contracts/access/Ownable.sol\\"";\\n\\ncontract OMTokenV2 is ERC20Capped, Ownable {\\n    constructor(address owner_) public ERC20(\\""MANTRA DAO\\"", \\""OM\\"") ERC20Capped(888888888 * 10**18) {\\n        transferOwnership(owner_);\\n    }\\n\\n    function mint(address account, uint256 amount) external onlyOwner returns (bool success) {\\n        _mint(account, amount);\\n        return true;\\n    }\\n\\n    function renounceOwnership() public override {\\n        require(totalSupply() == cap(), \\""Total supply not equals to cap\\"");\\n        super.renounceOwnership();\\n    }\\n}\\n""\r\n    },\r\n    ""openzeppelin-solidity/contracts/GSN/Context.sol"": {\r\n      ""content"": ""// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n""\r\n    },\r\n    ""openzeppelin-solidity/contracts/access/Ownable.sol"": {\r\n      ""content"": ""// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\""../GSN/Context.sol\\"";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\""Ownable: caller is not the owner\\"");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\""Ownable: new owner is the zero address\\"");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n""\r\n    },\r\n    ""openzeppelin-solidity/contracts/math/SafeMath.sol"": {\r\n      ""content"": ""// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity\'s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\'s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\'s `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\""SafeMath: addition overflow\\"");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\'s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\""SafeMath: subtraction overflow\\"");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\'s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\'s `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \'a\' not being zero, but the\\n        // benefit is lost if \'b\' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\""SafeMath: multiplication overflow\\"");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\'s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\""SafeMath: division by zero\\"");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\'s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\'t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity\'s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\""SafeMath: modulo by zero\\"");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity\'s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n""\r\n    },\r\n    ""openzeppelin-solidity/contracts/token/ERC20/ERC20.sol"": {\r\n      ""content"": ""// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\""../../GSN/Context.sol\\"";\\nimport \\""./IERC20.sol\\"";\\nimport \\""../../math/SafeMath.sol\\"";\\nimport \\""../../utils/Address.sol\\"";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn\'t required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n     * a default value of 18.\\n     *\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name, string memory symbol) public {\\n        _name = name;\\n        _symbol = symbol;\\n        _decimals = 18;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20};\\n     *\\n     * Requirements:\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``\'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\""ERC20: transfer amount exceeds allowance\\""));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\""ERC20: decreased allowance below zero\\""));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\""ERC20: transfer from the zero address\\"");\\n        require(recipient != address(0), \\""ERC20: transfer to the zero address\\"");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\""ERC20: transfer amount exceeds balance\\"");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\""ERC20: mint to the zero address\\"");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\""ERC20: burn from the zero address\\"");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\""ERC20: burn amount exceeds balance\\"");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\""ERC20: approve from the zero address\\"");\\n        require(spender != address(0), \\""ERC20: approve to the zero address\\"");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\n     *\\n     * WARNING: This function should only be called from the constructor. Most\\n     * applications that interact with token contracts will not expect\\n     * {decimals} to ever change, and may work incorrectly if it does.\\n     */\\n    function _setupDecimals(uint8 decimals_) internal {\\n        _decimals = decimals_;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``\'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n""\r\n    },\r\n    ""openzeppelin-solidity/contracts/token/ERC20/ERC20Capped.sol"": {\r\n      ""content"": ""// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\""./ERC20.sol\\"";\\n\\n/**\\n * @dev Extension of {ERC20} that adds a cap to the supply of tokens.\\n */\\nabstract contract ERC20Capped is ERC20 {\\n    uint256 private _cap;\\n\\n    /**\\n     * @dev Sets the value of the `cap`. This value is immutable, it can only be\\n     * set once during construction.\\n     */\\n    constructor (uint256 cap) public {\\n        require(cap > 0, \\""ERC20Capped: cap is 0\\"");\\n        _cap = cap;\\n    }\\n\\n    /**\\n     * @dev Returns the cap on the token\'s total supply.\\n     */\\n    function cap() public view returns (uint256) {\\n        return _cap;\\n    }\\n\\n    /**\\n     * @dev See {ERC20-_beforeTokenTransfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - minted tokens must not cause the total supply to go over the cap.\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\\n        super._beforeTokenTransfer(from, to, amount);\\n\\n        if (from == address(0)) { // When minting tokens\\n            require(totalSupply().add(amount) <= _cap, \\""ERC20Capped: cap exceeded\\"");\\n        }\\n    }\\n}\\n""\r\n    },\r\n    ""openzeppelin-solidity/contracts/token/ERC20/IERC20.sol"": {\r\n      ""content"": ""// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n""\r\n    },\r\n    ""openzeppelin-solidity/contracts/utils/Address.sol"": {\r\n      ""content"": ""// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.2;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies in extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\""Address: insufficient balance\\"");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\""\\"");\\n        require(success, \\""Address: unable to send value, recipient may have reverted\\"");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\""Address: low-level call failed\\"");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\""Address: low-level call with value failed\\"");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\""Address: insufficient balance for call\\"");\\n        return _functionCallWithValue(target, data, value, errorMessage);\\n    }\\n\\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\\n        require(isContract(target), \\""Address: call to non-contract\\"");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n""\r\n    }\r\n  },\r\n  ""settings"": {\r\n    ""remappings"": [],\r\n    ""optimizer"": {\r\n      ""enabled"": false,\r\n      ""runs"": 200\r\n    },\r\n    ""evmVersion"": ""constantinople"",\r\n    ""libraries"": {\r\n      """": {}\r\n    },\r\n    ""outputSelection"": {\r\n      ""*"": {\r\n        ""*"": [\r\n          ""evm.bytecode"",\r\n          ""evm.deployedBytecode"",\r\n          ""abi""\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}', 'ABI': '[{""inputs"":[{""internalType"":""address"",""name"":""owner_"",""type"":""address""}],""stateMutability"":""nonpayable"",""type"":""constructor""},{""anonymous"":false,""inputs"":[{""indexed"":true,""internalType"":""address"",""name"":""owner"",""type"":""address""},{""indexed"":true,""internalType"":""address"",""name"":""spender"",""type"":""address""},{""indexed"":false,""internalType"":""uint256"",""name"":""value"",""type"":""uint256""}],""name"":""Approval"",""type"":""event""},{""anonymous"":false,""inputs"":[{""indexed"":true,""internalType"":""address"",""name"":""previousOwner"",""type"":""address""},{""indexed"":true,""internalType"":""address"",""name"":""newOwner"",""type"":""address""}],""name"":""OwnershipTransferred"",""type"":""event""},{""anonymous"":false,""inputs"":[{""indexed"":true,""internalType"":""address"",""name"":""from"",""type"":""address""},{""indexed"":true,""internalType"":""address"",""name"":""to"",""type"":""address""},{""indexed"":false,""internalType"":""uint256"",""name"":""value"",""type"":""uint256""}],""name"":""Transfer"",""type"":""event""},{""inputs"":[{""internalType"":""address"",""name"":""owner"",""type"":""address""},{""internalType"":""address"",""name"":""spender"",""type"":""address""}],""name"":""allowance"",""outputs"":[{""internalType"":""uint256"",""name"":"""",""type"":""uint256""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[{""internalType"":""address"",""name"":""spender"",""type"":""address""},{""internalType"":""uint256"",""name"":""amount"",""type"":""uint256""}],""name"":""approve"",""outputs"":[{""internalType"":""bool"",""name"":"""",""type"":""bool""}],""stateMutability"":""nonpayable"",""type"":""function""},{""inputs"":[{""internalType"":""address"",""name"":""account"",""type"":""address""}],""name"":""balanceOf"",""outputs"":[{""internalType"":""uint256"",""name"":"""",""type"":""uint256""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[],""name"":""cap"",""outputs"":[{""internalType"":""uint256"",""name"":"""",""type"":""uint256""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[],""name"":""decimals"",""outputs"":[{""internalType"":""uint8"",""name"":"""",""type"":""uint8""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[{""internalType"":""address"",""name"":""spender"",""type"":""address""},{""internalType"":""uint256"",""name"":""subtractedValue"",""type"":""uint256""}],""name"":""decreaseAllowance"",""outputs"":[{""internalType"":""bool"",""name"":"""",""type"":""bool""}],""stateMutability"":""nonpayable"",""type"":""function""},{""inputs"":[{""internalType"":""address"",""name"":""spender"",""type"":""address""},{""internalType"":""uint256"",""name"":""addedValue"",""type"":""uint256""}],""name"":""increaseAllowance"",""outputs"":[{""internalType"":""bool"",""name"":"""",""type"":""bool""}],""stateMutability"":""nonpayable"",""type"":""function""},{""inputs"":[{""internalType"":""address"",""name"":""account"",""type"":""address""},{""internalType"":""uint256"",""name"":""amount"",""type"":""uint256""}],""name"":""mint"",""outputs"":[{""internalType"":""bool"",""name"":""success"",""type"":""bool""}],""stateMutability"":""nonpayable"",""type"":""function""},{""inputs"":[],""name"":""name"",""outputs"":[{""internalType"":""string"",""name"":"""",""type"":""string""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[],""name"":""owner"",""outputs"":[{""internalType"":""address"",""name"":"""",""type"":""address""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[],""name"":""renounceOwnership"",""outputs"":[],""stateMutability"":""nonpayable"",""type"":""function""},{""inputs"":[],""name"":""symbol"",""outputs"":[{""internalType"":""string"",""name"":"""",""type"":""string""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[],""name"":""totalSupply"",""outputs"":[{""internalType"":""uint256"",""name"":"""",""type"":""uint256""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[{""internalType"":""address"",""name"":""recipient"",""type"":""address""},{""internalType"":""uint256"",""name"":""amount"",""type"":""uint256""}],""name"":""transfer"",""outputs"":[{""internalType"":""bool"",""name"":"""",""type"":""bool""}],""stateMutability"":""nonpayable"",""type"":""function""},{""inputs"":[{""internalType"":""address"",""name"":""sender"",""type"":""address""},{""internalType"":""address"",""name"":""recipient"",""type"":""address""},{""internalType"":""uint256"",""name"":""amount"",""type"":""uint256""}],""name"":""transferFrom"",""outputs"":[{""internalType"":""bool"",""name"":"""",""type"":""bool""}],""stateMutability"":""nonpayable"",""type"":""function""},{""inputs"":[{""internalType"":""address"",""name"":""newOwner"",""type"":""address""}],""name"":""transferOwnership"",""outputs"":[],""stateMutability"":""nonpayable"",""type"":""function""}]', 'ContractName': 'OMTokenV2', 'CompilerVersion': 'v0.6.12+commit.27d51765', 'OptimizationUsed': '0', 'Runs': '200', 'ConstructorArguments': '000000000000000000000000fa0e08b7e80e6e7eecad9800bc32ef19132da295', 'EVMVersion': 'constantinople', 'Library': '', 'LicenseType': '', 'Proxy': '0', 'Implementation': '', 'SwarmSource': ''}]"
1,OK,"[{'SourceCode': '// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.0;\r\nlibrary Strings {\r\n    bytes16 private constant _HEX_SYMBOLS = ""0123456789abcdef"";\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return ""0"";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return ""0x00"";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 length = 0;\r\n        while (temp != 0) {\r\n            length++;\r\n            temp >>= 8;\r\n        }\r\n        return toHexString(value, length);\r\n    }\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = ""0"";\r\n        buffer[1] = ""x"";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0, ""Strings: hex length insufficient"");\r\n        return string(buffer);\r\n    }\r\n}\r\npragma solidity ^0.8.0;\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\npragma solidity ^0.8.0;\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), ""Ownable: caller is not the owner"");\r\n        _;\r\n    }\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), ""Ownable: new owner is the zero address"");\r\n        _transferOwnership(newOwner);\r\n    }\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\npragma solidity ^0.8.1;\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        return account.code.length > 0;\r\n    }\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, ""Address: insufficient balance"");\r\n\r\n        (bool success, ) = recipient.call{value: amount}("""");\r\n        require(success, ""Address: unable to send value, recipient may have reverted"");\r\n    }\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, ""Address: low-level call failed"");\r\n    }\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, ""Address: low-level call with value failed"");\r\n    }\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, ""Address: insufficient balance for call"");\r\n        require(isContract(target), ""Address: call to non-contract"");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, ""Address: low-level static call failed"");\r\n    }\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), ""Address: static call to non-contract"");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, ""Address: low-level delegate call failed"");\r\n    }\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), ""Address: delegate call to non-contract"");\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length > 0) {\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC721Receiver {\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\nabstract contract ERC165 is IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\ninterface IERC721 is IERC165 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\ninterface IERC721Enumerable is IERC721 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\r\n\r\n    function tokenByIndex(uint256 index) external view returns (uint256);\r\n}\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\ninterface IERC721Metadata is IERC721 {\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\r\n    using Address for address;\r\n    using Strings for uint256;\r\n\r\n    string private _name;\r\n\r\n    string private _symbol;\r\n\r\n    mapping(uint256 => address) private _owners;\r\n\r\n    mapping(address => uint256) private _balances;\r\n\r\n    mapping(uint256 => address) private _tokenApprovals;\r\n\r\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\r\n        return\r\n            interfaceId == type(IERC721).interfaceId ||\r\n            interfaceId == type(IERC721Metadata).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    function balanceOf(address owner) public view virtual override returns (uint256) {\r\n        require(owner != address(0), ""ERC721: balance query for the zero address"");\r\n        return _balances[owner];\r\n    }\r\n\r\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\r\n        address owner = _owners[tokenId];\r\n        require(owner != address(0), ""ERC721: owner query for nonexistent token"");\r\n        return owner;\r\n    }\r\n\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\r\n        require(_exists(tokenId), ""ERC721Metadata: URI query for nonexistent token"");\r\n\r\n        string memory baseURI = _baseURI();\r\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : """";\r\n    }\r\n\r\n    function _baseURI() internal view virtual returns (string memory) {\r\n        return """";\r\n    }\r\n\r\n    function approve(address to, uint256 tokenId) public virtual override {\r\n        address owner = ERC721.ownerOf(tokenId);\r\n        require(to != owner, ""ERC721: approval to current owner"");\r\n\r\n        require(\r\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\r\n            ""ERC721: approve caller is not owner nor approved for all""\r\n        );\r\n\r\n        _approve(to, tokenId);\r\n    }\r\n\r\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\r\n        require(_exists(tokenId), ""ERC721: approved query for nonexistent token"");\r\n\r\n        return _tokenApprovals[tokenId];\r\n    }\r\n\r\n    function setApprovalForAll(address operator, bool approved) public virtual override {\r\n        _setApprovalForAll(_msgSender(), operator, approved);\r\n    }\r\n\r\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public virtual override {\r\n        require(_isApprovedOrOwner(_msgSender(), tokenId), ""ERC721: transfer caller is not owner nor approved"");\r\n\r\n        _transfer(from, to, tokenId);\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public virtual override {\r\n        safeTransferFrom(from, to, tokenId, """");\r\n    }\r\n\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) public virtual override {\r\n        require(_isApprovedOrOwner(_msgSender(), tokenId), ""ERC721: transfer caller is not owner nor approved"");\r\n        _safeTransfer(from, to, tokenId, _data);\r\n    }\r\n\r\n    function _safeTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) internal virtual {\r\n        _transfer(from, to, tokenId);\r\n        require(_checkOnERC721Received(from, to, tokenId, _data), ""ERC721: transfer to non ERC721Receiver implementer"");\r\n    }\r\n\r\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\r\n        return _owners[tokenId] != address(0);\r\n    }\r\n\r\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\r\n        require(_exists(tokenId), ""ERC721: operator query for nonexistent token"");\r\n        address owner = ERC721.ownerOf(tokenId);\r\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\r\n    }\r\n\r\n    function _safeMint(address to, uint256 tokenId) internal virtual {\r\n        _safeMint(to, tokenId, """");\r\n    }\r\n\r\n    function _safeMint(\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) internal virtual {\r\n        _mint(to, tokenId);\r\n        require(\r\n            _checkOnERC721Received(address(0), to, tokenId, _data),\r\n            ""ERC721: transfer to non ERC721Receiver implementer""\r\n        );\r\n    }\r\n\r\n    function _mint(address to, uint256 tokenId) internal virtual {\r\n        require(to != address(0), ""ERC721: mint to the zero address"");\r\n        require(!_exists(tokenId), ""ERC721: token already minted"");\r\n\r\n        _beforeTokenTransfer(address(0), to, tokenId);\r\n\r\n        _balances[to] += 1;\r\n        _owners[tokenId] = to;\r\n\r\n        emit Transfer(address(0), to, tokenId);\r\n\r\n        _afterTokenTransfer(address(0), to, tokenId);\r\n    }\r\n\r\n    function _burn(uint256 tokenId) internal virtual {\r\n        address owner = ERC721.ownerOf(tokenId);\r\n\r\n        _beforeTokenTransfer(owner, address(0), tokenId);\r\n\r\n        _approve(address(0), tokenId);\r\n\r\n        _balances[owner] -= 1;\r\n        delete _owners[tokenId];\r\n\r\n        emit Transfer(owner, address(0), tokenId);\r\n\r\n        _afterTokenTransfer(owner, address(0), tokenId);\r\n    }\r\n\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal virtual {\r\n        require(ERC721.ownerOf(tokenId) == from, ""ERC721: transfer from incorrect owner"");\r\n        require(to != address(0), ""ERC721: transfer to the zero address"");\r\n\r\n        _beforeTokenTransfer(from, to, tokenId);\r\n\r\n        _approve(address(0), tokenId);\r\n\r\n        _balances[from] -= 1;\r\n        _balances[to] += 1;\r\n        _owners[tokenId] = to;\r\n\r\n        emit Transfer(from, to, tokenId);\r\n\r\n        _afterTokenTransfer(from, to, tokenId);\r\n    }\r\n\r\n    function _approve(address to, uint256 tokenId) internal virtual {\r\n        _tokenApprovals[tokenId] = to;\r\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\r\n    }\r\n\r\n    function _setApprovalForAll(\r\n        address owner,\r\n        address operator,\r\n        bool approved\r\n    ) internal virtual {\r\n        require(owner != operator, ""ERC721: approve to caller"");\r\n        _operatorApprovals[owner][operator] = approved;\r\n        emit ApprovalForAll(owner, operator, approved);\r\n    }\r\n\r\n    function _checkOnERC721Received(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) private returns (bool) {\r\n        if (to.isContract()) {\r\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\r\n                return retval == IERC721Receiver.onERC721Received.selector;\r\n            } catch (bytes memory reason) {\r\n                if (reason.length == 0) {\r\n                    revert(""ERC721: transfer to non ERC721Receiver implementer"");\r\n                } else {\r\n                    assembly {\r\n                        revert(add(32, reason), mload(reason))\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal virtual {}\r\n\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal virtual {}\r\n}\r\n\r\npragma solidity ^0.8.0;\r\n\r\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\r\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\r\n\r\n    mapping(uint256 => uint256) private _ownedTokensIndex;\r\n\r\n    uint256[] private _allTokens;\r\n\r\n    mapping(uint256 => uint256) private _allTokensIndex;\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\r\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\r\n        require(index < ERC721.balanceOf(owner), ""ERC721Enumerable: owner index out of bounds"");\r\n        return _ownedTokens[owner][index];\r\n    }\r\n\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _allTokens.length;\r\n    }\r\n\r\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\r\n        require(index < ERC721Enumerable.totalSupply(), ""ERC721Enumerable: global index out of bounds"");\r\n        return _allTokens[index];\r\n    }\r\n\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal virtual override {\r\n        super._beforeTokenTransfer(from, to, tokenId);\r\n\r\n        if (from == address(0)) {\r\n            _addTokenToAllTokensEnumeration(tokenId);\r\n        } else if (from != to) {\r\n            _removeTokenFromOwnerEnumeration(from, tokenId);\r\n        }\r\n        if (to == address(0)) {\r\n            _removeTokenFromAllTokensEnumeration(tokenId);\r\n        } else if (to != from) {\r\n            _addTokenToOwnerEnumeration(to, tokenId);\r\n        }\r\n    }\r\n\r\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\r\n        uint256 length = ERC721.balanceOf(to);\r\n        _ownedTokens[to][length] = tokenId;\r\n        _ownedTokensIndex[tokenId] = length;\r\n    }\r\n\r\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\r\n        _allTokensIndex[tokenId] = _allTokens.length;\r\n        _allTokens.push(tokenId);\r\n    }\r\n\r\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\r\n\r\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\r\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\r\n\r\n        if (tokenIndex != lastTokenIndex) {\r\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\r\n\r\n            _ownedTokens[from][tokenIndex] = lastTokenId;\r\n            _ownedTokensIndex[lastTokenId] = tokenIndex;\r\n        }\r\n\r\n        delete _ownedTokensIndex[tokenId];\r\n        delete _ownedTokens[from][lastTokenIndex];\r\n    }\r\n\r\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\r\n\r\n        uint256 lastTokenIndex = _allTokens.length - 1;\r\n        uint256 tokenIndex = _allTokensIndex[tokenId];\r\n\r\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\r\n\r\n        _allTokens[tokenIndex] = lastTokenId;\r\n        _allTokensIndex[lastTokenId] = tokenIndex;\r\n\r\n        delete _allTokensIndex[tokenId];\r\n        _allTokens.pop();\r\n    }\r\n}\r\n\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\ncontract NFT is ERC721Enumerable, Ownable {\r\n  using Strings for uint256;\r\n\r\n  string public baseURI;\r\n  string public baseExtension = "".json"";\r\n  uint256 public cost = 0.0042 ether;\r\n  uint256 public maxSupply = 2222;\r\n  uint256 public maxMintAmount = 100;\r\n  bool public paused = false;\r\n  mapping(address => bool) public whitelisted;\r\n\r\n  constructor() ERC721(""PunkToadz"", ""PT"") {\r\n    setBaseURI(""https://bafybeiglrxiswcqbxjzlrqebtc4nfakeetw2iueruvmxverl4u37rzeija.ipfs.w3s.link/"");\r\n  }\r\n\r\n  function _baseURI() internal view virtual override returns (string memory) {\r\n    return baseURI;\r\n  }\r\n\r\n  function mint(address _to, uint256 _mintAmount) public payable {\r\n    uint256 supply = totalSupply();\r\n    require(!paused);\r\n    require(_mintAmount > 0);\r\n    require(_mintAmount <= maxMintAmount);\r\n    require(supply + _mintAmount <= maxSupply);\r\n\r\n    if (msg.sender != owner()) {\r\n        if(whitelisted[msg.sender] != true) {\r\n          require(msg.value >= cost * _mintAmount);\r\n        }\r\n    }\r\n\r\n    for (uint256 i = 1; i <= _mintAmount; i++) {\r\n      _safeMint(_to, supply + i);\r\n    }\r\n  }\r\n\r\n  function walletOfOwner(address _owner)\r\n    public\r\n    view\r\n    returns (uint256[] memory)\r\n  {\r\n    uint256 ownerTokenCount = balanceOf(_owner);\r\n    uint256[] memory tokenIds = new uint256[](ownerTokenCount);\r\n    for (uint256 i; i < ownerTokenCount; i++) {\r\n      tokenIds[i] = tokenOfOwnerByIndex(_owner, i);\r\n    }\r\n    return tokenIds;\r\n  }\r\n\r\n  function tokenURI(uint256 tokenId)\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (string memory)\r\n  {\r\n    require(\r\n      _exists(tokenId),\r\n      ""ERC721Metadata: URI query for nonexistent token""\r\n    );\r\n\r\n    string memory currentBaseURI = _baseURI();\r\n    return bytes(currentBaseURI).length > 0\r\n        ? string(abi.encodePacked(currentBaseURI, tokenId.toString(), baseExtension))\r\n        : """";\r\n  }\r\n\r\n  function setCost(uint256 _newCost) public onlyOwner {\r\n    cost = _newCost;\r\n  }\r\n\r\n  function setmaxMintAmount(uint256 _newmaxMintAmount) public onlyOwner {\r\n    maxMintAmount = _newmaxMintAmount;\r\n  }\r\n\r\n  function setBaseURI(string memory _newBaseURI) public onlyOwner {\r\n    baseURI = _newBaseURI;\r\n  }\r\n\r\n  function setBaseExtension(string memory _newBaseExtension) public onlyOwner {\r\n    baseExtension = _newBaseExtension;\r\n  }\r\n\r\n  function pause(bool _state) public onlyOwner {\r\n    paused = _state;\r\n  }\r\n \r\n  function whitelistUser(address _user) public onlyOwner {\r\n    whitelisted[_user] = true;\r\n  }\r\n \r\n  function removeWhitelistUser(address _user) public onlyOwner {\r\n    whitelisted[_user] = false;\r\n  }\r\n\r\n  function withdraw() public payable onlyOwner {\r\n    (bool os, ) = payable(owner()).call{value: address(this).balance}("""");\r\n    require(os);\r\n  }\r\n}', 'ABI': '[{""inputs"":[],""stateMutability"":""nonpayable"",""type"":""constructor""},{""anonymous"":false,""inputs"":[{""indexed"":true,""internalType"":""address"",""name"":""owner"",""type"":""address""},{""indexed"":true,""internalType"":""address"",""name"":""approved"",""type"":""address""},{""indexed"":true,""internalType"":""uint256"",""name"":""tokenId"",""type"":""uint256""}],""name"":""Approval"",""type"":""event""},{""anonymous"":false,""inputs"":[{""indexed"":true,""internalType"":""address"",""name"":""owner"",""type"":""address""},{""indexed"":true,""internalType"":""address"",""name"":""operator"",""type"":""address""},{""indexed"":false,""internalType"":""bool"",""name"":""approved"",""type"":""bool""}],""name"":""ApprovalForAll"",""type"":""event""},{""anonymous"":false,""inputs"":[{""indexed"":true,""internalType"":""address"",""name"":""previousOwner"",""type"":""address""},{""indexed"":true,""internalType"":""address"",""name"":""newOwner"",""type"":""address""}],""name"":""OwnershipTransferred"",""type"":""event""},{""anonymous"":false,""inputs"":[{""indexed"":true,""internalType"":""address"",""name"":""from"",""type"":""address""},{""indexed"":true,""internalType"":""address"",""name"":""to"",""type"":""address""},{""indexed"":true,""internalType"":""uint256"",""name"":""tokenId"",""type"":""uint256""}],""name"":""Transfer"",""type"":""event""},{""inputs"":[{""internalType"":""address"",""name"":""to"",""type"":""address""},{""internalType"":""uint256"",""name"":""tokenId"",""type"":""uint256""}],""name"":""approve"",""outputs"":[],""stateMutability"":""nonpayable"",""type"":""function""},{""inputs"":[{""internalType"":""address"",""name"":""owner"",""type"":""address""}],""name"":""balanceOf"",""outputs"":[{""internalType"":""uint256"",""name"":"""",""type"":""uint256""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[],""name"":""baseExtension"",""outputs"":[{""internalType"":""string"",""name"":"""",""type"":""string""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[],""name"":""baseURI"",""outputs"":[{""internalType"":""string"",""name"":"""",""type"":""string""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[],""name"":""cost"",""outputs"":[{""internalType"":""uint256"",""name"":"""",""type"":""uint256""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[{""internalType"":""uint256"",""name"":""tokenId"",""type"":""uint256""}],""name"":""getApproved"",""outputs"":[{""internalType"":""address"",""name"":"""",""type"":""address""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[{""internalType"":""address"",""name"":""owner"",""type"":""address""},{""internalType"":""address"",""name"":""operator"",""type"":""address""}],""name"":""isApprovedForAll"",""outputs"":[{""internalType"":""bool"",""name"":"""",""type"":""bool""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[],""name"":""maxMintAmount"",""outputs"":[{""internalType"":""uint256"",""name"":"""",""type"":""uint256""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[],""name"":""maxSupply"",""outputs"":[{""internalType"":""uint256"",""name"":"""",""type"":""uint256""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[{""internalType"":""address"",""name"":""_to"",""type"":""address""},{""internalType"":""uint256"",""name"":""_mintAmount"",""type"":""uint256""}],""name"":""mint"",""outputs"":[],""stateMutability"":""payable"",""type"":""function""},{""inputs"":[],""name"":""name"",""outputs"":[{""internalType"":""string"",""name"":"""",""type"":""string""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[],""name"":""owner"",""outputs"":[{""internalType"":""address"",""name"":"""",""type"":""address""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[{""internalType"":""uint256"",""name"":""tokenId"",""type"":""uint256""}],""name"":""ownerOf"",""outputs"":[{""internalType"":""address"",""name"":"""",""type"":""address""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[{""internalType"":""bool"",""name"":""_state"",""type"":""bool""}],""name"":""pause"",""outputs"":[],""stateMutability"":""nonpayable"",""type"":""function""},{""inputs"":[],""name"":""paused"",""outputs"":[{""internalType"":""bool"",""name"":"""",""type"":""bool""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[{""internalType"":""address"",""name"":""_user"",""type"":""address""}],""name"":""removeWhitelistUser"",""outputs"":[],""stateMutability"":""nonpayable"",""type"":""function""},{""inputs"":[],""name"":""renounceOwnership"",""outputs"":[],""stateMutability"":""nonpayable"",""type"":""function""},{""inputs"":[{""internalType"":""address"",""name"":""from"",""type"":""address""},{""internalType"":""address"",""name"":""to"",""type"":""address""},{""internalType"":""uint256"",""name"":""tokenId"",""type"":""uint256""}],""name"":""safeTransferFrom"",""outputs"":[],""stateMutability"":""nonpayable"",""type"":""function""},{""inputs"":[{""internalType"":""address"",""name"":""from"",""type"":""address""},{""internalType"":""address"",""name"":""to"",""type"":""address""},{""internalType"":""uint256"",""name"":""tokenId"",""type"":""uint256""},{""internalType"":""bytes"",""name"":""_data"",""type"":""bytes""}],""name"":""safeTransferFrom"",""outputs"":[],""stateMutability"":""nonpayable"",""type"":""function""},{""inputs"":[{""internalType"":""address"",""name"":""operator"",""type"":""address""},{""internalType"":""bool"",""name"":""approved"",""type"":""bool""}],""name"":""setApprovalForAll"",""outputs"":[],""stateMutability"":""nonpayable"",""type"":""function""},{""inputs"":[{""internalType"":""string"",""name"":""_newBaseExtension"",""type"":""string""}],""name"":""setBaseExtension"",""outputs"":[],""stateMutability"":""nonpayable"",""type"":""function""},{""inputs"":[{""internalType"":""string"",""name"":""_newBaseURI"",""type"":""string""}],""name"":""setBaseURI"",""outputs"":[],""stateMutability"":""nonpayable"",""type"":""function""},{""inputs"":[{""internalType"":""uint256"",""name"":""_newCost"",""type"":""uint256""}],""name"":""setCost"",""outputs"":[],""stateMutability"":""nonpayable"",""type"":""function""},{""inputs"":[{""internalType"":""uint256"",""name"":""_newmaxMintAmount"",""type"":""uint256""}],""name"":""setmaxMintAmount"",""outputs"":[],""stateMutability"":""nonpayable"",""type"":""function""},{""inputs"":[{""internalType"":""bytes4"",""name"":""interfaceId"",""type"":""bytes4""}],""name"":""supportsInterface"",""outputs"":[{""internalType"":""bool"",""name"":"""",""type"":""bool""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[],""name"":""symbol"",""outputs"":[{""internalType"":""string"",""name"":"""",""type"":""string""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[{""internalType"":""uint256"",""name"":""index"",""type"":""uint256""}],""name"":""tokenByIndex"",""outputs"":[{""internalType"":""uint256"",""name"":"""",""type"":""uint256""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[{""internalType"":""address"",""name"":""owner"",""type"":""address""},{""internalType"":""uint256"",""name"":""index"",""type"":""uint256""}],""name"":""tokenOfOwnerByIndex"",""outputs"":[{""internalType"":""uint256"",""name"":"""",""type"":""uint256""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[{""internalType"":""uint256"",""name"":""tokenId"",""type"":""uint256""}],""name"":""tokenURI"",""outputs"":[{""internalType"":""string"",""name"":"""",""type"":""string""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[],""name"":""totalSupply"",""outputs"":[{""internalType"":""uint256"",""name"":"""",""type"":""uint256""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[{""internalType"":""address"",""name"":""from"",""type"":""address""},{""internalType"":""address"",""name"":""to"",""type"":""address""},{""internalType"":""uint256"",""name"":""tokenId"",""type"":""uint256""}],""name"":""transferFrom"",""outputs"":[],""stateMutability"":""nonpayable"",""type"":""function""},{""inputs"":[{""internalType"":""address"",""name"":""newOwner"",""type"":""address""}],""name"":""transferOwnership"",""outputs"":[],""stateMutability"":""nonpayable"",""type"":""function""},{""inputs"":[{""internalType"":""address"",""name"":""_owner"",""type"":""address""}],""name"":""walletOfOwner"",""outputs"":[{""internalType"":""uint256[]"",""name"":"""",""type"":""uint256[]""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[{""internalType"":""address"",""name"":""_user"",""type"":""address""}],""name"":""whitelistUser"",""outputs"":[],""stateMutability"":""nonpayable"",""type"":""function""},{""inputs"":[{""internalType"":""address"",""name"":"""",""type"":""address""}],""name"":""whitelisted"",""outputs"":[{""internalType"":""bool"",""name"":"""",""type"":""bool""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[],""name"":""withdraw"",""outputs"":[],""stateMutability"":""payable"",""type"":""function""}]', 'ContractName': 'NFT', 'CompilerVersion': 'v0.8.15+commit.e14f2714', 'OptimizationUsed': '0', 'Runs': '200', 'ConstructorArguments': '', 'EVMVersion': 'Default', 'Library': '', 'LicenseType': 'MIT', 'Proxy': '0', 'Implementation': '', 'SwarmSource': 'ipfs://0bc8ec03d90069b521684efb5992897483161531de6a8d6ee785f0170fa88c0c'}]"
1,OK,"[{'SourceCode': '// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.10;\r\n\r\n/**\r\n * @dev Wrappers over Solidity\'s arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it\'s recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\'s `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, ""SafeMath: addition overflow"");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\'s `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, ""SafeMath: subtraction overflow"");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\'s `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\'s `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring \'a\' not being zero, but the\r\n        // benefit is lost if \'b\' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, ""SafeMath: multiplication overflow"");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\'s `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, ""SafeMath: division by zero"");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\'s `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn\'t hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\'s `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, ""SafeMath: modulo by zero"");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\'s `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender\'s allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller\'s\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Ownable is a contract the provides contract ownership functionality, including a two-\r\n * phase transfer.\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n    address private _authorizedNewOwner;\r\n\r\n    /**\r\n     * @notice Emitted when the owner authorizes ownership transfer to a new address\r\n     * @param authorizedAddress New owner address\r\n     */\r\n    event OwnershipTransferAuthorization(address indexed authorizedAddress);\r\n\r\n    /**\r\n     * @notice Emitted when the authorized address assumed ownership\r\n     * @param oldValue Old owner\r\n     * @param newValue New owner\r\n     */\r\n    event OwnerUpdate(address indexed oldValue, address indexed newValue);\r\n\r\n    /**\r\n     * @notice Sets the owner to the sender / contract creator\r\n     */\r\n    constructor() internal {\r\n        _owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves the owner of the contract\r\n     * @return The contract owner\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves the authorized new owner of the contract\r\n     * @return The authorized new contract owner\r\n     */\r\n    function authorizedNewOwner() public view returns (address) {\r\n        return _authorizedNewOwner;\r\n    }\r\n\r\n    /**\r\n     * @notice Authorizes the transfer of ownership from owner to the provided address.\r\n     * NOTE: No transfer will occur unless authorizedAddress calls assumeOwnership().\r\n     * This authorization may be removed by another call to this function authorizing the zero\r\n     * address.\r\n     * @param _authorizedAddress The address authorized to become the new owner\r\n     */\r\n    function authorizeOwnershipTransfer(address _authorizedAddress) external {\r\n        require(msg.sender == _owner, ""Invalid sender"");\r\n\r\n        _authorizedNewOwner = _authorizedAddress;\r\n\r\n        emit OwnershipTransferAuthorization(_authorizedNewOwner);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers ownership of this contract to the _authorizedNewOwner\r\n     * @dev Error invalid sender.\r\n     */\r\n    function assumeOwnership() external {\r\n        require(msg.sender == _authorizedNewOwner, ""Invalid sender"");\r\n\r\n        address oldValue = _owner;\r\n        _owner = _authorizedNewOwner;\r\n        _authorizedNewOwner = address(0);\r\n\r\n        emit OwnerUpdate(oldValue, _owner);\r\n    }\r\n}\r\n\r\nabstract contract ERC1820Registry {\r\n    function setInterfaceImplementer(\r\n        address _addr,\r\n        bytes32 _interfaceHash,\r\n        address _implementer\r\n    ) external virtual;\r\n\r\n    function getInterfaceImplementer(address _addr, bytes32 _interfaceHash)\r\n        external\r\n        virtual\r\n        view\r\n        returns (address);\r\n\r\n    function setManager(address _addr, address _newManager) external virtual;\r\n\r\n    function getManager(address _addr) public virtual view returns (address);\r\n}\r\n\r\n/// Base client to interact with the registry.\r\ncontract ERC1820Client {\r\n    ERC1820Registry constant ERC1820REGISTRY = ERC1820Registry(\r\n        0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24\r\n    );\r\n\r\n    function setInterfaceImplementation(\r\n        string memory _interfaceLabel,\r\n        address _implementation\r\n    ) internal {\r\n        bytes32 interfaceHash = keccak256(abi.encodePacked(_interfaceLabel));\r\n        ERC1820REGISTRY.setInterfaceImplementer(\r\n            address(this),\r\n            interfaceHash,\r\n            _implementation\r\n        );\r\n    }\r\n\r\n    function interfaceAddr(address addr, string memory _interfaceLabel)\r\n        internal\r\n        view\r\n        returns (address)\r\n    {\r\n        bytes32 interfaceHash = keccak256(abi.encodePacked(_interfaceLabel));\r\n        return ERC1820REGISTRY.getInterfaceImplementer(addr, interfaceHash);\r\n    }\r\n\r\n    function delegateManagement(address _newManager) internal {\r\n        ERC1820REGISTRY.setManager(address(this), _newManager);\r\n    }\r\n}\r\n\r\ncontract ERC1820Implementer {\r\n    /**\r\n     * @dev ERC1820 well defined magic value indicating the contract has\r\n     * registered with the ERC1820Registry that it can implement an interface.\r\n     */\r\n    bytes32 constant ERC1820_ACCEPT_MAGIC = keccak256(\r\n        abi.encodePacked(""ERC1820_ACCEPT_MAGIC"")\r\n    );\r\n\r\n    /**\r\n     * @dev Mapping of interface name keccak256 hashes for which this contract\r\n     * implements the interface.\r\n     * @dev Only settable internally.\r\n     */\r\n    mapping(bytes32 => bool) internal _interfaceHashes;\r\n\r\n    /**\r\n     * @notice Indicates whether the contract implements the interface `_interfaceHash`\r\n     * for the address `_addr`.\r\n     * @param _interfaceHash keccak256 hash of the name of the interface.\r\n     * @return ERC1820_ACCEPT_MAGIC only if the contract implements `nterfaceHash`\r\n     * for the address `_addr`.\r\n     * @dev In this implementation, the `_addr` (the address for which the\r\n     * contract will implement the interface) is always `address(this)`.\r\n     */\r\n    function canImplementInterfaceForAddress(\r\n        bytes32 _interfaceHash,\r\n        address // Comments to avoid compilation warnings for unused variables. /*addr*/\r\n    ) external view returns (bytes32) {\r\n        if (_interfaceHashes[_interfaceHash]) {\r\n            return ERC1820_ACCEPT_MAGIC;\r\n        } else {\r\n            return """";\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Internally set the fact this contract implements the interface\r\n     * identified by `_interfaceLabel`\r\n     * @param _interfaceLabel String representation of the interface.\r\n     */\r\n    function _setInterface(string memory _interfaceLabel) internal {\r\n        _interfaceHashes[keccak256(abi.encodePacked(_interfaceLabel))] = true;\r\n    }\r\n}\r\n\r\n/**\r\n * @title IAmpTokensSender\r\n * @dev IAmpTokensSender token transfer hook interface\r\n */\r\ninterface IAmpTokensSender {\r\n    /**\r\n     * @dev Report if the transfer will succeed from the pespective of the\r\n     * token sender\r\n     */\r\n    function canTransfer(\r\n        bytes4 functionSig,\r\n        bytes32 partition,\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 value,\r\n        bytes calldata data,\r\n        bytes calldata operatorData\r\n    ) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Hook executed upon a transfer on behalf of the sender\r\n     */\r\n    function tokensToTransfer(\r\n        bytes4 functionSig,\r\n        bytes32 partition,\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 value,\r\n        bytes calldata data,\r\n        bytes calldata operatorData\r\n    ) external;\r\n}\r\n\r\n/**\r\n * @title IAmpTokensRecipient\r\n * @dev IAmpTokensRecipient token transfer hook interface\r\n */\r\ninterface IAmpTokensRecipient {\r\n    /**\r\n     * @dev Report if the recipient will successfully receive the tokens\r\n     */\r\n    function canReceive(\r\n        bytes4 functionSig,\r\n        bytes32 partition,\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 value,\r\n        bytes calldata data,\r\n        bytes calldata operatorData\r\n    ) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Hook executed upon a transfer to the recipient\r\n     */\r\n    function tokensReceived(\r\n        bytes4 functionSig,\r\n        bytes32 partition,\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 value,\r\n        bytes calldata data,\r\n        bytes calldata operatorData\r\n    ) external;\r\n}\r\n\r\n/**\r\n * @notice Partition strategy validator hooks for Amp\r\n */\r\ninterface IAmpPartitionStrategyValidator {\r\n    function tokensFromPartitionToValidate(\r\n        bytes4 _functionSig,\r\n        bytes32 _partition,\r\n        address _operator,\r\n        address _from,\r\n        address _to,\r\n        uint256 _value,\r\n        bytes calldata _data,\r\n        bytes calldata _operatorData\r\n    ) external;\r\n\r\n    function tokensToPartitionToValidate(\r\n        bytes4 _functionSig,\r\n        bytes32 _partition,\r\n        address _operator,\r\n        address _from,\r\n        address _to,\r\n        uint256 _value,\r\n        bytes calldata _data,\r\n        bytes calldata _operatorData\r\n    ) external;\r\n\r\n    function isOperatorForPartitionScope(\r\n        bytes32 _partition,\r\n        address _operator,\r\n        address _tokenHolder\r\n    ) external view returns (bool);\r\n}\r\n\r\n/**\r\n * @title PartitionUtils\r\n * @notice Partition related helper functions.\r\n */\r\n\r\nlibrary PartitionUtils {\r\n    bytes32 public constant CHANGE_PARTITION_FLAG = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\r\n\r\n    /**\r\n     * @notice Retrieve the destination partition from the \'data\' field.\r\n     * A partition change is requested ONLY when \'data\' starts with the flag:\r\n     *\r\n     *   0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\r\n     *\r\n     * When the flag is detected, the destination partition is extracted from the\r\n     * 32 bytes following the flag.\r\n     * @param _data Information attached to the transfer. Will contain the\r\n     * destination partition if a change is requested.\r\n     * @param _fallbackPartition Partition value to return if a partition change\r\n     * is not requested in the `_data`.\r\n     * @return toPartition Destination partition. If the `_data` does not contain\r\n     * the prefix and bytes32 partition in the first 64 bytes, the method will\r\n     * return the provided `_fromPartition`.\r\n     */\r\n    function _getDestinationPartition(bytes memory _data, bytes32 _fallbackPartition)\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        if (_data.length < 64) {\r\n            return _fallbackPartition;\r\n        }\r\n\r\n        (bytes32 flag, bytes32 toPartition) = abi.decode(_data, (bytes32, bytes32));\r\n        if (flag == CHANGE_PARTITION_FLAG) {\r\n            return toPartition;\r\n        }\r\n\r\n        return _fallbackPartition;\r\n    }\r\n\r\n    /**\r\n     * @notice Helper to get the strategy identifying prefix from the `_partition`.\r\n     * @param _partition Partition to get the prefix for.\r\n     * @return 4 byte partition strategy prefix.\r\n     */\r\n    function _getPartitionPrefix(bytes32 _partition) internal pure returns (bytes4) {\r\n        return bytes4(_partition);\r\n    }\r\n\r\n    /**\r\n     * @notice Helper method to split the partition into the prefix, sub partition\r\n     * and partition owner components.\r\n     * @param _partition The partition to split into parts.\r\n     * @return The 4 byte partition prefix, 8 byte sub partition, and final 20\r\n     * bytes representing an address.\r\n     */\r\n    function _splitPartition(bytes32 _partition)\r\n        internal\r\n        pure\r\n        returns (\r\n            bytes4,\r\n            bytes8,\r\n            address\r\n        )\r\n    {\r\n        bytes4 prefix = bytes4(_partition);\r\n        bytes8 subPartition = bytes8(_partition << 32);\r\n        address addressPart = address(uint160(uint256(_partition)));\r\n        return (prefix, subPartition, addressPart);\r\n    }\r\n\r\n    /**\r\n     * @notice Helper method to get a partition strategy ERC1820 interface name\r\n     * based on partition prefix.\r\n     * @param _prefix 4 byte partition prefix.\r\n     * @dev Each 4 byte prefix has a unique interface name so that an individual\r\n     * hook implementation can be set for each prefix.\r\n     */\r\n    function _getPartitionStrategyValidatorIName(bytes4 _prefix)\r\n        internal\r\n        pure\r\n        returns (string memory)\r\n    {\r\n        return string(abi.encodePacked(""AmpPartitionStrategyValidator"", _prefix));\r\n    }\r\n}\r\n\r\n/**\r\n * @title ErrorCodes\r\n * @notice Amp error codes.\r\n */\r\ncontract ErrorCodes {\r\n    string internal EC_50_TRANSFER_FAILURE = ""50"";\r\n    string internal EC_51_TRANSFER_SUCCESS = ""51"";\r\n    string internal EC_52_INSUFFICIENT_BALANCE = ""52"";\r\n    string internal EC_53_INSUFFICIENT_ALLOWANCE = ""53"";\r\n\r\n    string internal EC_56_INVALID_SENDER = ""56"";\r\n    string internal EC_57_INVALID_RECEIVER = ""57"";\r\n    string internal EC_58_INVALID_OPERATOR = ""58"";\r\n\r\n    string internal EC_59_INSUFFICIENT_RIGHTS = ""59"";\r\n\r\n    string internal EC_5A_INVALID_SWAP_TOKEN_ADDRESS = ""5A"";\r\n    string internal EC_5B_INVALID_VALUE_0 = ""5B"";\r\n    string internal EC_5C_ADDRESS_CONFLICT = ""5C"";\r\n    string internal EC_5D_PARTITION_RESERVED = ""5D"";\r\n    string internal EC_5E_PARTITION_PREFIX_CONFLICT = ""5E"";\r\n    string internal EC_5F_INVALID_PARTITION_PREFIX_0 = ""5F"";\r\n    string internal EC_60_SWAP_TRANSFER_FAILURE = ""60"";\r\n}\r\n\r\ninterface ISwapToken {\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256 remaining);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool success);\r\n}\r\n\r\n/**\r\n * @title Amp\r\n * @notice Amp is an ERC20 compatible collateral token designed to support\r\n * multiple classes of collateralization systems.\r\n * @dev The Amp token contract includes the following features:\r\n *\r\n * Partitions\r\n *   Tokens can be segmented within a given address by ""partition"", which in\r\n *   pracice is a 32 byte identifier. These partitions can have unique\r\n *   permissions globally, through the using of partition strategies, and\r\n *   locally, on a per address basis. The ability to create the sub-segments\r\n *   of tokens and assign special behavior gives collateral managers\r\n *   flexibility in how they are implemented.\r\n *\r\n * Operators\r\n *   Inspired by ERC777, Amp allows token holders to assign ""operators"" on\r\n *   all (or any number of partitions) of their tokens. Operators are allowed\r\n *   to execute transfers on behalf of token owners without the need to use the\r\n *   ERC20 ""allowance"" semantics.\r\n *\r\n * Transfers with Data\r\n *   Inspired by ERC777, Amp transfers can include arbitrary data, as well as\r\n *   operator data. This data can be used to change the partition of tokens,\r\n *   be used by collateral manager hooks to validate a transfer, be propagated\r\n *   via event to an off chain system, etc.\r\n *\r\n * Token Transfer Hooks on Send and Receive\r\n *   Inspired by ERC777, Amp uses the ERC1820 Registry to allow collateral\r\n *   manager implementations to register hooks to be called upon sending to\r\n *   or transferring from the collateral manager\'s address or, using partition\r\n *   strategies, owned partition space. The hook implementations can be used\r\n *   to validate transfer properties, gate transfers, emit custom events,\r\n *   update local state, etc.\r\n *\r\n * Collateral Management Partition Strategies\r\n *   Amp is able to define certain sets of partitions, identified by a 4 byte\r\n *   prefix, that will allow special, custom logic to be executed when transfers\r\n *   are made to or from those partitions. This opens up the possibility of\r\n *   entire classes of collateral management systems that would not be possible\r\n *   without it.\r\n *\r\n * These features give collateral manager implementers flexibility while\r\n * providing a consistent, ""collateral-in-place"", interface for interacting\r\n * with collateral systems directly through the Amp contract.\r\n */\r\ncontract Amp is IERC20, ERC1820Client, ERC1820Implementer, ErrorCodes, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    /**************************************************************************/\r\n    /********************** ERC1820 Interface Constants ***********************/\r\n\r\n    /**\r\n     * @dev AmpToken interface label.\r\n     */\r\n    string internal constant AMP_INTERFACE_NAME = ""AmpToken"";\r\n\r\n    /**\r\n     * @dev ERC20Token interface label.\r\n     */\r\n    string internal constant ERC20_INTERFACE_NAME = ""ERC20Token"";\r\n\r\n    /**\r\n     * @dev AmpTokensSender interface label.\r\n     */\r\n    string internal constant AMP_TOKENS_SENDER = ""AmpTokensSender"";\r\n\r\n    /**\r\n     * @dev AmpTokensRecipient interface label.\r\n     */\r\n    string internal constant AMP_TOKENS_RECIPIENT = ""AmpTokensRecipient"";\r\n\r\n    /**\r\n     * @dev AmpTokensChecker interface label.\r\n     */\r\n    string internal constant AMP_TOKENS_CHECKER = ""AmpTokensChecker"";\r\n\r\n    /**************************************************************************/\r\n    /*************************** Token properties *****************************/\r\n\r\n    /**\r\n     * @dev Token name (Amp).\r\n     */\r\n    string internal _name;\r\n\r\n    /**\r\n     * @dev Token symbol (AMP).\r\n     */\r\n    string internal _symbol;\r\n\r\n    /**\r\n     * @dev Total minted supply of token. This will increase comensurately with\r\n     * successful swaps of the swap token.\r\n     */\r\n    uint256 internal _totalSupply;\r\n\r\n    /**\r\n     * @dev The granularity of the token. Hard coded to 1.\r\n     */\r\n    uint256 internal constant _granularity = 1;\r\n\r\n    /**************************************************************************/\r\n    /***************************** Token mappings *****************************/\r\n\r\n    /**\r\n     * @dev Mapping from tokenHolder to balance. This reflects the balance\r\n     * across all partitions of an address.\r\n     */\r\n    mapping(address => uint256) internal _balances;\r\n\r\n    /**************************************************************************/\r\n    /************************** Partition mappings ****************************/\r\n\r\n    /**\r\n     * @dev List of active partitions. This list reflects all partitions that\r\n     * have tokens assigned to them.\r\n     */\r\n    bytes32[] internal _totalPartitions;\r\n\r\n    /**\r\n     * @dev Mapping from partition to their index.\r\n     */\r\n    mapping(bytes32 => uint256) internal _indexOfTotalPartitions;\r\n\r\n    /**\r\n     * @dev Mapping from partition to global balance of corresponding partition.\r\n     */\r\n    mapping(bytes32 => uint256) public totalSupplyByPartition;\r\n\r\n    /**\r\n     * @dev Mapping from tokenHolder to their partitions.\r\n     */\r\n    mapping(address => bytes32[]) internal _partitionsOf;\r\n\r\n    /**\r\n     * @dev Mapping from (tokenHolder, partition) to their index.\r\n     */\r\n    mapping(address => mapping(bytes32 => uint256)) internal _indexOfPartitionsOf;\r\n\r\n    /**\r\n     * @dev Mapping from (tokenHolder, partition) to balance of corresponding\r\n     * partition.\r\n     */\r\n    mapping(address => mapping(bytes32 => uint256)) internal _balanceOfByPartition;\r\n\r\n    /**\r\n     * @notice Default partition of the token.\r\n     * @dev All ERC20 operations operate solely on this partition.\r\n     */\r\n    bytes32\r\n        public constant defaultPartition = 0x0000000000000000000000000000000000000000000000000000000000000000;\r\n\r\n    /**\r\n     * @dev Zero partition prefix. Parititions with this prefix can not have\r\n     * a strategy assigned, and partitions with a different prefix must have one.\r\n     */\r\n    bytes4 internal constant ZERO_PREFIX = 0x00000000;\r\n\r\n    /**************************************************************************/\r\n    /***************************** Operator mappings **************************/\r\n\r\n    /**\r\n     * @dev Mapping from (tokenHolder, operator) to authorized status. This is\r\n     * specific to the token holder.\r\n     */\r\n    mapping(address => mapping(address => bool)) internal _authorizedOperator;\r\n\r\n    /**************************************************************************/\r\n    /********************** Partition operator mappings ***********************/\r\n\r\n    /**\r\n     * @dev Mapping from (partition, tokenHolder, spender) to allowed value.\r\n     * This is specific to the token holder.\r\n     */\r\n    mapping(bytes32 => mapping(address => mapping(address => uint256)))\r\n        internal _allowedByPartition;\r\n\r\n    /**\r\n     * @dev Mapping from (tokenHolder, partition, operator) to \'approved for\r\n     * partition\' status. This is specific to the token holder.\r\n     */\r\n    mapping(address => mapping(bytes32 => mapping(address => bool)))\r\n        internal _authorizedOperatorByPartition;\r\n\r\n    /**************************************************************************/\r\n    /********************** Collateral Manager mappings ***********************/\r\n    /**\r\n     * @notice Collection of registered collateral managers.\r\n     */\r\n    address[] public collateralManagers;\r\n    /**\r\n     * @dev Mapping of collateral manager addresses to registration status.\r\n     */\r\n    mapping(address => bool) internal _isCollateralManager;\r\n\r\n    /**************************************************************************/\r\n    /********************* Partition Strategy mappings ************************/\r\n\r\n    /**\r\n     * @notice Collection of reserved partition strategies.\r\n     */\r\n    bytes4[] public partitionStrategies;\r\n\r\n    /**\r\n     * @dev Mapping of partition strategy flag to registration status.\r\n     */\r\n    mapping(bytes4 => bool) internal _isPartitionStrategy;\r\n\r\n    /**************************************************************************/\r\n    /***************************** Swap storage *******************************/\r\n\r\n    /**\r\n     * @notice Swap token address. Immutable.\r\n     */\r\n    ISwapToken public swapToken;\r\n\r\n    /**\r\n     * @notice Swap token graveyard address.\r\n     * @dev This is the address that the incoming swapped tokens will be\r\n     * forwarded to upon successfully minting Amp.\r\n     */\r\n    address\r\n        public constant swapTokenGraveyard = 0x000000000000000000000000000000000000dEaD;\r\n\r\n    /**************************************************************************/\r\n    /** EVENTS ****************************************************************/\r\n    /**************************************************************************/\r\n\r\n    /**************************************************************************/\r\n    /**************************** Transfer Events *****************************/\r\n\r\n    /**\r\n     * @notice Emitted when a transfer has been successfully completed.\r\n     * @param fromPartition The partition the tokens were transfered from.\r\n     * @param operator The address that initiated the transfer.\r\n     * @param from The address the tokens were transferred from.\r\n     * @param to The address the tokens were transferred to.\r\n     * @param value The amount of tokens transferred.\r\n     * @param data Additional metadata included with the transfer. Can include\r\n     * the partition the tokens were transferred to (if different than\r\n     * `fromPartition`).\r\n     * @param operatorData Additional metadata included with the transfer on\r\n     * behalf of the operator.\r\n     */\r\n    event TransferByPartition(\r\n        bytes32 indexed fromPartition,\r\n        address operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 value,\r\n        bytes data,\r\n        bytes operatorData\r\n    );\r\n\r\n    /**\r\n     * @notice Emitted when a transfer has been successfully completed and the\r\n     * tokens that were transferred have changed partitions.\r\n     * @param fromPartition The partition the tokens were transfered from.\r\n     * @param toPartition The partition the tokens were transfered to.\r\n     * @param value The amount of tokens transferred.\r\n     */\r\n    event ChangedPartition(\r\n        bytes32 indexed fromPartition,\r\n        bytes32 indexed toPartition,\r\n        uint256 value\r\n    );\r\n\r\n    /**************************************************************************/\r\n    /**************************** Operator Events *****************************/\r\n\r\n    /**\r\n     * @notice Emitted when a token holder specifies an amount of tokens in a\r\n     * a partition that an operator can transfer.\r\n     * @param partition The partition of the tokens the holder has authorized the\r\n     * operator to transfer from.\r\n     * @param owner The token holder.\r\n     * @param spender The operator the `owner` has authorized the allowance for.\r\n     */\r\n    event ApprovalByPartition(\r\n        bytes32 indexed partition,\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n\r\n    /**\r\n     * @notice Emitted when a token holder has authorized an operator for their\r\n     * tokens.\r\n     * @dev This event applies to the token holder address across all partitions.\r\n     * @param operator The address that was authorized to transfer tokens on\r\n     * behalf of the `tokenHolder`.\r\n     * @param tokenHolder The address that authorized the `operator` to transfer\r\n     * their tokens.\r\n     */\r\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\r\n\r\n    /**\r\n     * @notice Emitted when a token holder has de-authorized an operator from\r\n     * transferring their tokens.\r\n     * @dev This event applies to the token holder address across all partitions.\r\n     * @param operator The address that was de-authorized from transferring tokens\r\n     * on behalf of the `tokenHolder`.\r\n     * @param tokenHolder The address that revoked the `operator`\'s permission\r\n     * to transfer their tokens.\r\n     */\r\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\r\n\r\n    /**\r\n     * @notice Emitted when a token holder has authorized an operator to transfer\r\n     * their tokens of one partition.\r\n     * @param partition The partition the `operator` is allowed to transfer\r\n     * tokens from.\r\n     * @param operator The address that was authorized to transfer tokens on\r\n     * behalf of the `tokenHolder`.\r\n     * @param tokenHolder The address that authorized the `operator` to transfer\r\n     * their tokens in `partition`.\r\n     */\r\n    event AuthorizedOperatorByPartition(\r\n        bytes32 indexed partition,\r\n        address indexed operator,\r\n        address indexed tokenHolder\r\n    );\r\n\r\n    /**\r\n     * @notice Emitted when a token holder has de-authorized an operator from\r\n     * transferring their tokens from a specific partition.\r\n     * @param partition The partition the `operator` is no longer allowed to\r\n     * transfer tokens from on behalf of the `tokenHolder`.\r\n     * @param operator The address that was de-authorized from transferring\r\n     * tokens on behalf of the `tokenHolder`.\r\n     * @param tokenHolder The address that revoked the `operator`\'s permission\r\n     * to transfer their tokens from `partition`.\r\n     */\r\n    event RevokedOperatorByPartition(\r\n        bytes32 indexed partition,\r\n        address indexed operator,\r\n        address indexed tokenHolder\r\n    );\r\n\r\n    /**************************************************************************/\r\n    /********************** Collateral Manager Events *************************/\r\n\r\n    /**\r\n     * @notice Emitted when a collateral manager has been registered.\r\n     * @param collateralManager The address of the collateral manager.\r\n     */\r\n    event CollateralManagerRegistered(address collateralManager);\r\n\r\n    /**************************************************************************/\r\n    /*********************** Partition Strategy Events ************************/\r\n\r\n    /**\r\n     * @notice Emitted when a new partition strategy validator is set.\r\n     * @param flag The 4 byte prefix of the partitions that the stratgy affects.\r\n     * @param name The name of the partition strategy.\r\n     * @param implementation The address of the partition strategy hook\r\n     * implementation.\r\n     */\r\n    event PartitionStrategySet(bytes4 flag, string name, address indexed implementation);\r\n\r\n    // ************** Mint & Swap **************\r\n\r\n    /**\r\n     * @notice Emitted when tokens are minted as a result of a token swap\r\n     * @param operator Address that executed the swap that resulted in tokens being minted\r\n     * @param to Address that received the newly minted tokens.\r\n     * @param value Amount of tokens minted\r\n     * @param data Empty bytes, required for interface compatibility\r\n     */\r\n    event Minted(address indexed operator, address indexed to, uint256 value, bytes data);\r\n\r\n    /**\r\n     * @notice Indicates tokens swapped for Amp.\r\n     * @dev The tokens that are swapped for Amp will be transferred to a\r\n     * graveyard address that is for all practical purposes inaccessible.\r\n     * @param operator Address that executed the swap.\r\n     * @param from Address that the tokens were swapped from, and Amp minted for.\r\n     * @param value Amount of tokens swapped into Amp.\r\n     */\r\n    event Swap(address indexed operator, address indexed from, uint256 value);\r\n\r\n    /**************************************************************************/\r\n    /** CONSTRUCTOR ***********************************************************/\r\n    /**************************************************************************/\r\n\r\n    /**\r\n     * @notice Initialize Amp, initialize the default partition, and register the\r\n     * contract implementation in the global ERC1820Registry.\r\n     * @param _swapTokenAddress_ The address of the ERC20 token that is set to be\r\n     * swappable for Amp.\r\n     * @param _name_ Name of the token.\r\n     * @param _symbol_ Symbol of the token.\r\n     */\r\n    constructor(\r\n        address _swapTokenAddress_,\r\n        string memory _name_,\r\n        string memory _symbol_\r\n    ) public {\r\n        // ""Swap token cannot be 0 address""\r\n        require(_swapTokenAddress_ != address(0), EC_5A_INVALID_SWAP_TOKEN_ADDRESS);\r\n        swapToken = ISwapToken(_swapTokenAddress_);\r\n\r\n        _name = _name_;\r\n        _symbol = _symbol_;\r\n        _totalSupply = 0;\r\n\r\n        // Add the default partition to the total partitions on deploy\r\n        _addPartitionToTotalPartitions(defaultPartition);\r\n\r\n        // Register contract in ERC1820 registry\r\n        ERC1820Client.setInterfaceImplementation(AMP_INTERFACE_NAME, address(this));\r\n        ERC1820Client.setInterfaceImplementation(ERC20_INTERFACE_NAME, address(this));\r\n\r\n        // Indicate token verifies Amp and ERC20 interfaces\r\n        ERC1820Implementer._setInterface(AMP_INTERFACE_NAME);\r\n        ERC1820Implementer._setInterface(ERC20_INTERFACE_NAME);\r\n    }\r\n\r\n    /**************************************************************************/\r\n    /** EXTERNAL FUNCTIONS (ERC20) ********************************************/\r\n    /**************************************************************************/\r\n\r\n    /**\r\n     * @notice Get the total number of issued tokens.\r\n     * @return Total supply of tokens currently in circulation.\r\n     */\r\n    function totalSupply() external override view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @notice Get the balance of the account with address `_tokenHolder`.\r\n     * @dev This returns the balance of the holder across all partitions. Note\r\n     * that due to other functionality in Amp, this figure should not be used\r\n     * as the arbiter of the amount a token holder will successfully be able to\r\n     * send via the ERC20 compatible `transfer` method. In order to get that\r\n     * figure, use `balanceOfByParition` and to get the balance of the default\r\n     * partition.\r\n     * @param _tokenHolder Address for which the balance is returned.\r\n     * @return Amount of token held by `_tokenHolder` in the default partition.\r\n     */\r\n    function balanceOf(address _tokenHolder) external override view returns (uint256) {\r\n        return _balances[_tokenHolder];\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer token for a specified address.\r\n     * @dev This method is for ERC20 compatibility, and only affects the\r\n     * balance of the `msg.sender` address\'s default partition.\r\n     * @param _to The address to transfer to.\r\n     * @param _value The value to be transferred.\r\n     * @return A boolean that indicates if the operation was successful.\r\n     */\r\n    function transfer(address _to, uint256 _value) external override returns (bool) {\r\n        _transferByDefaultPartition(msg.sender, msg.sender, _to, _value, """");\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer tokens from one address to another.\r\n     * @dev This method is for ERC20 compatibility, and only affects the\r\n     * balance and allowance of the `_from` address\'s default partition.\r\n     * @param _from The address which you want to transfer tokens from.\r\n     * @param _to The address which you want to transfer to.\r\n     * @param _value The amount of tokens to be transferred.\r\n     * @return A boolean that indicates if the operation was successful.\r\n     */\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) external override returns (bool) {\r\n        _transferByDefaultPartition(msg.sender, _from, _to, _value, """");\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Check the value of tokens that an owner allowed to a spender.\r\n     * @dev This method is for ERC20 compatibility, and only affects the\r\n     * allowance of the `msg.sender`\'s default partition.\r\n     * @param _owner address The address which owns the funds.\r\n     * @param _spender address The address which will spend the funds.\r\n     * @return A uint256 specifying the value of tokens still available for the\r\n     * spender.\r\n     */\r\n    function allowance(address _owner, address _spender)\r\n        external\r\n        override\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _allowedByPartition[defaultPartition][_owner][_spender];\r\n    }\r\n\r\n    /**\r\n     * @notice Approve the passed address to spend the specified amount of\r\n     * tokens from the default partition on behalf of \'msg.sender\'.\r\n     * @dev This method is for ERC20 compatibility, and only affects the\r\n     * allowance of the `msg.sender`\'s default partition.\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _value The amount of tokens to be spent.\r\n     * @return A boolean that indicates if the operation was successful.\r\n     */\r\n    function approve(address _spender, uint256 _value) external override returns (bool) {\r\n        _approveByPartition(defaultPartition, msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Atomically increases the allowance granted to `_spender` by the\r\n     * for caller.\r\n     * @dev This is an alternative to {approve} that can be used as a mitigation\r\n     * problems described in {IERC20-approve}.\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     * Requirements:\r\n     * - `_spender` cannot be the zero address.\r\n     * @dev This method is for ERC20 compatibility, and only affects the\r\n     * allowance of the `msg.sender`\'s default partition.\r\n     * @param _spender Operator allowed to transfer the tokens\r\n     * @param _addedValue Additional amount of the `msg.sender`s tokens `_spender`\r\n     * is allowed to transfer\r\n     * @return \'true\' is successful, \'false\' otherwise\r\n     */\r\n    function increaseAllowance(address _spender, uint256 _addedValue)\r\n        external\r\n        returns (bool)\r\n    {\r\n        _approveByPartition(\r\n            defaultPartition,\r\n            msg.sender,\r\n            _spender,\r\n            _allowedByPartition[defaultPartition][msg.sender][_spender].add(_addedValue)\r\n        );\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Atomically decreases the allowance granted to `_spender` by the\r\n     * caller.\r\n     * @dev This is an alternative to {approve} that can be used as a mitigation\r\n     * for bugs caused by reentrancy.\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     * Requirements:\r\n     * - `_spender` cannot be the zero address.\r\n     * - `_spender` must have allowance for the caller of at least\r\n     * `_subtractedValue`.\r\n     * @dev This method is for ERC20 compatibility, and only affects the\r\n     * allowance of the `msg.sender`\'s default partition.\r\n     * @param _spender Operator allowed to transfer the tokens\r\n     * @param _subtractedValue Amount of the `msg.sender`s tokens `_spender`\r\n     * is no longer allowed to transfer\r\n     * @return \'true\' is successful, \'false\' otherwise\r\n     */\r\n    function decreaseAllowance(address _spender, uint256 _subtractedValue)\r\n        external\r\n        returns (bool)\r\n    {\r\n        _approveByPartition(\r\n            defaultPartition,\r\n            msg.sender,\r\n            _spender,\r\n            _allowedByPartition[defaultPartition][msg.sender][_spender].sub(\r\n                _subtractedValue\r\n            )\r\n        );\r\n        return true;\r\n    }\r\n\r\n    /**************************************************************************/\r\n    /** EXTERNAL FUNCTIONS (AMP) **********************************************/\r\n    /**************************************************************************/\r\n\r\n    /******************************** Swap  ***********************************/\r\n\r\n    /**\r\n     * @notice Swap tokens to mint AMP.\r\n     * @dev Requires `_from` to have given allowance of swap token to contract.\r\n     * Otherwise will throw error code 53 (Insuffient Allowance).\r\n     * @param _from Token holder to execute the swap for.\r\n     */\r\n    function swap(address _from) public {\r\n        uint256 amount = swapToken.allowance(_from, address(this));\r\n        require(amount > 0, EC_53_INSUFFICIENT_ALLOWANCE);\r\n\r\n        require(\r\n            swapToken.transferFrom(_from, swapTokenGraveyard, amount),\r\n            EC_60_SWAP_TRANSFER_FAILURE\r\n        );\r\n\r\n        _mint(msg.sender, _from, amount);\r\n\r\n        emit Swap(msg.sender, _from, amount);\r\n    }\r\n\r\n    /**************************************************************************/\r\n    /************************** Holder information ****************************/\r\n\r\n    /**\r\n     * @notice Get balance of a tokenholder for a specific partition.\r\n     * @param _partition Name of the partition.\r\n     * @param _tokenHolder Address for which the balance is returned.\r\n     * @return Amount of token of partition `_partition` held by `_tokenHolder` in the token contract.\r\n     */\r\n    function balanceOfByPartition(bytes32 _partition, address _tokenHolder)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _balanceOfByPartition[_tokenHolder][_partition];\r\n    }\r\n\r\n    /**\r\n     * @notice Get partitions index of a token holder.\r\n     * @param _tokenHolder Address for which the partitions index are returned.\r\n     * @return Array of partitions index of \'_tokenHolder\'.\r\n     */\r\n    function partitionsOf(address _tokenHolder) external view returns (bytes32[] memory) {\r\n        return _partitionsOf[_tokenHolder];\r\n    }\r\n\r\n    /**************************************************************************/\r\n    /************************** Advanced Transfers ****************************/\r\n\r\n    /**\r\n     * @notice Transfer tokens from a specific partition on behalf of a token\r\n     * holder, optionally changing the parittion and optionally including\r\n     * arbitrary data with the transfer.\r\n     * @dev This can be used to transfer an address\'s own tokens, or transfer\r\n     * a different addresses tokens by specifying the `_from` param. If\r\n     * attempting to transfer from a different address than `msg.sender`, the\r\n     * `msg.sender` will need to be an operator or have enough allowance for the\r\n     * `_partition` of the `_from` address.\r\n     * @param _partition Name of the partition to transfer from.\r\n     * @param _from Token holder.\r\n     * @param _to Token recipient.\r\n     * @param _value Number of tokens to transfer.\r\n     * @param _data Information attached to the transfer. Will contain the\r\n     * destination partition (if changing partitions).\r\n     * @param _operatorData Information attached to the transfer, by the operator.\r\n     * @return Destination partition.\r\n     */\r\n    function transferByPartition(\r\n        bytes32 _partition,\r\n        address _from,\r\n        address _to,\r\n        uint256 _value,\r\n        bytes calldata _data,\r\n        bytes calldata _operatorData\r\n    ) external returns (bytes32) {\r\n        return\r\n            _transferByPartition(\r\n                _partition,\r\n                msg.sender,\r\n                _from,\r\n                _to,\r\n                _value,\r\n                _data,\r\n                _operatorData\r\n            );\r\n    }\r\n\r\n    /**************************************************************************/\r\n    /************************** Operator Management ***************************/\r\n\r\n    /**\r\n     * @notice Set a third party operator address as an operator of \'msg.sender\'\r\n     * to transfer and redeem tokens on its behalf.\r\n     * @dev The msg.sender is always an operator for itself, and does not need to\r\n     * be explicitly added.\r\n     * @param _operator Address to set as an operator for \'msg.sender\'.\r\n     */\r\n    function authorizeOperator(address _operator) external {\r\n        require(_operator != msg.sender, EC_58_INVALID_OPERATOR);\r\n\r\n        _authorizedOperator[msg.sender][_operator] = true;\r\n        emit AuthorizedOperator(_operator, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Remove the right of the operator address to be an operator for\r\n     * \'msg.sender\' and to transfer and redeem tokens on its behalf.\r\n     * @dev The msg.sender is always an operator for itself, and cannot be\r\n     * removed.\r\n     * @param _operator Address to rescind as an operator for \'msg.sender\'.\r\n     */\r\n    function revokeOperator(address _operator) external {\r\n        require(_operator != msg.sender, EC_58_INVALID_OPERATOR);\r\n\r\n        _authorizedOperator[msg.sender][_operator] = false;\r\n        emit RevokedOperator(_operator, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Set `_operator` as an operator for \'msg.sender\' for a given partition.\r\n     * @dev The msg.sender is always an operator for itself, and does not need to\r\n     * be explicitly added to a partition.\r\n     * @param _partition Name of the partition.\r\n     * @param _operator Address to set as an operator for \'msg.sender\'.\r\n     */\r\n    function authorizeOperatorByPartition(bytes32 _partition, address _operator)\r\n        external\r\n    {\r\n        require(_operator != msg.sender, EC_58_INVALID_OPERATOR);\r\n\r\n        _authorizedOperatorByPartition[msg.sender][_partition][_operator] = true;\r\n        emit AuthorizedOperatorByPartition(_partition, _operator, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Remove the right of the operator address to be an operator on a\r\n     * given partition for \'msg.sender\' and to transfer and redeem tokens on its\r\n     * behalf.\r\n     * @dev The msg.sender is always an operator for itself, and cannot be\r\n     * removed from a partition.\r\n     * @param _partition Name of the partition.\r\n     * @param _operator Address to rescind as an operator on given partition for\r\n     * \'msg.sender\'.\r\n     */\r\n    function revokeOperatorByPartition(bytes32 _partition, address _operator) external {\r\n        require(_operator != msg.sender, EC_58_INVALID_OPERATOR);\r\n\r\n        _authorizedOperatorByPartition[msg.sender][_partition][_operator] = false;\r\n        emit RevokedOperatorByPartition(_partition, _operator, msg.sender);\r\n    }\r\n\r\n    /**************************************************************************/\r\n    /************************** Operator Information **************************/\r\n    /**\r\n     * @notice Indicate whether the `_operator` address is an operator of the\r\n     * `_tokenHolder` address.\r\n     * @dev An operator in this case is an operator across all of the partitions\r\n     * of the `msg.sender` address.\r\n     * @param _operator Address which may be an operator of `_tokenHolder`.\r\n     * @param _tokenHolder Address of a token holder which may have the\r\n     * `_operator` address as an operator.\r\n     * @return \'true\' if operator is an operator of \'tokenHolder\' and \'false\'\r\n     * otherwise.\r\n     */\r\n    function isOperator(address _operator, address _tokenHolder)\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _isOperator(_operator, _tokenHolder);\r\n    }\r\n\r\n    /**\r\n     * @notice Indicate whether the operator address is an operator of the\r\n     * `_tokenHolder` address for the given partition.\r\n     * @param _partition Name of the partition.\r\n     * @param _operator Address which may be an operator of tokenHolder for the\r\n     * given partition.\r\n     * @param _tokenHolder Address of a token holder which may have the\r\n     * `_operator` address as an operator for the given partition.\r\n     * @return \'true\' if \'operator\' is an operator of `_tokenHolder` for\r\n     * partition \'_partition\' and \'false\' otherwise.\r\n     */\r\n    function isOperatorForPartition(\r\n        bytes32 _partition,\r\n        address _operator,\r\n        address _tokenHolder\r\n    ) external view returns (bool) {\r\n        return _isOperatorForPartition(_partition, _operator, _tokenHolder);\r\n    }\r\n\r\n    /**\r\n     * @notice Indicate when the `_operator` address is an operator of the\r\n     * `_collateralManager` address for the given partition.\r\n     * @dev This method is the same as `isOperatorForPartition`, except that it\r\n     * also requires the address that `_operator` is being checked for MUST be\r\n     * a registered collateral manager, and this method will not execute\r\n     * partition strategy operator check hooks.\r\n     * @param _partition Name of the partition.\r\n     * @param _operator Address which may be an operator of `_collateralManager`\r\n     * for the given partition.\r\n     * @param _collateralManager Address of a collateral manager which may have\r\n     * the `_operator` address as an operator for the given partition.\r\n     */\r\n    function isOperatorForCollateralManager(\r\n        bytes32 _partition,\r\n        address _operator,\r\n        address _collateralManager\r\n    ) external view returns (bool) {\r\n        return\r\n            _isCollateralManager[_collateralManager] &&\r\n            (_isOperator(_operator, _collateralManager) ||\r\n                _authorizedOperatorByPartition[_collateralManager][_partition][_operator]);\r\n    }\r\n\r\n    /**************************************************************************/\r\n    /***************************** Token metadata *****************************/\r\n    /**\r\n     * @notice Get the name of the token (Amp).\r\n     * @return Name of the token.\r\n     */\r\n    function name() external view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @notice Get the symbol of the token (AMP).\r\n     * @return Symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @notice Get the number of decimals of the token.\r\n     * @dev Hard coded to 18.\r\n     * @return The number of decimals of the token (18).\r\n     */\r\n    function decimals() external pure returns (uint8) {\r\n        return uint8(18);\r\n    }\r\n\r\n    /**\r\n     * @notice Get the smallest part of the token thats not divisible.\r\n     * @dev Hard coded to 1.\r\n     * @return The smallest non-divisible part of the token.\r\n     */\r\n    function granularity() external pure returns (uint256) {\r\n        return _granularity;\r\n    }\r\n\r\n    /**\r\n     * @notice Get list of existing partitions.\r\n     * @return Array of all exisiting partitions.\r\n     */\r\n    function totalPartitions() external view returns (bytes32[] memory) {\r\n        return _totalPartitions;\r\n    }\r\n\r\n    /************************************************************************************************/\r\n    /******************************** Partition Token Allowances ************************************/\r\n    /**\r\n     * @notice Check the value of tokens that an owner allowed to a spender.\r\n     * @param _partition Name of the partition.\r\n     * @param _owner The address which owns the tokens.\r\n     * @param _spender The address which will spend the tokens.\r\n     * @return The value of tokens still for the spender to transfer.\r\n     */\r\n    function allowanceByPartition(\r\n        bytes32 _partition,\r\n        address _owner,\r\n        address _spender\r\n    ) external view returns (uint256) {\r\n        return _allowedByPartition[_partition][_owner][_spender];\r\n    }\r\n\r\n    /**\r\n     * @notice Approve the `_spender` address to spend the specified amount of\r\n     * tokens in `_partition` on behalf of \'msg.sender\'.\r\n     * @param _partition Name of the partition.\r\n     * @param _spender The address which will spend the tokens.\r\n     * @param _value The amount of tokens to be tokens.\r\n     * @return A boolean that indicates if the operation was successful.\r\n     */\r\n    function approveByPartition(\r\n        bytes32 _partition,\r\n        address _spender,\r\n        uint256 _value\r\n    ) external returns (bool) {\r\n        _approveByPartition(_partition, msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Atomically increases the allowance granted to `_spender` by the\r\n     * caller.\r\n     * @dev This is an alternative to {approveByPartition} that can be used as\r\n     * a mitigation for bugs caused by reentrancy.\r\n     * Emits an {ApprovalByPartition} event indicating the updated allowance.\r\n     * Requirements:\r\n     * - `_spender` cannot be the zero address.\r\n     * @param _partition Name of the partition.\r\n     * @param _spender Operator allowed to transfer the tokens\r\n     * @param _addedValue Additional amount of the `msg.sender`s tokens `_spender`\r\n     * is allowed to transfer\r\n     * @return \'true\' is successful, \'false\' otherwise\r\n     */\r\n    function increaseAllowanceByPartition(\r\n        bytes32 _partition,\r\n        address _spender,\r\n        uint256 _addedValue\r\n    ) external returns (bool) {\r\n        _approveByPartition(\r\n            _partition,\r\n            msg.sender,\r\n            _spender,\r\n            _allowedByPartition[_partition][msg.sender][_spender].add(_addedValue)\r\n        );\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Atomically decreases the allowance granted to `_spender` by the\r\n     * caller.\r\n     * @dev This is an alternative to {approveByPartition} that can be used as\r\n     * a mitigation for bugs caused by reentrancy.\r\n     * Emits an {ApprovalByPartition} event indicating the updated allowance.\r\n     * Requirements:\r\n     * - `_spender` cannot be the zero address.\r\n     * - `_spender` must have allowance for the caller of at least\r\n     * `_subtractedValue`.\r\n     * @param _spender Operator allowed to transfer the tokens\r\n     * @param _subtractedValue Amount of the `msg.sender`s tokens `_spender` is\r\n     * no longer allowed to transfer\r\n     * @return \'true\' is successful, \'false\' otherwise\r\n     */\r\n    function decreaseAllowanceByPartition(\r\n        bytes32 _partition,\r\n        address _spender,\r\n        uint256 _subtractedValue\r\n    ) external returns (bool) {\r\n        // TOOD: Figure out if safe math will panic below 0\r\n        _approveByPartition(\r\n            _partition,\r\n            msg.sender,\r\n            _spender,\r\n            _allowedByPartition[_partition][msg.sender][_spender].sub(_subtractedValue)\r\n        );\r\n        return true;\r\n    }\r\n\r\n    /**************************************************************************/\r\n    /************************ Collateral Manager Admin ************************/\r\n\r\n    /**\r\n     * @notice Allow a collateral manager to self-register.\r\n     * @dev Error 0x5c.\r\n     */\r\n    function registerCollateralManager() external {\r\n        // Short circuit a double registry\r\n        require(!_isCollateralManager[msg.sender], EC_5C_ADDRESS_CONFLICT);\r\n\r\n        collateralManagers.push(msg.sender);\r\n        _isCollateralManager[msg.sender] = true;\r\n\r\n        emit CollateralManagerRegistered(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Get the status of a collateral manager.\r\n     * @param _collateralManager The address of the collateral mananger in question.\r\n     * @return \'true\' if `_collateralManager` has self registered, \'false\'\r\n     * otherwise.\r\n     */\r\n    function isCollateralManager(address _collateralManager)\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _isCollateralManager[_collateralManager];\r\n    }\r\n\r\n    /**************************************************************************/\r\n    /************************ Partition Strategy Admin ************************/\r\n    /**\r\n     * @notice Sets an implementation for a partition strategy identified by prefix.\r\n     * @dev This is an administration method, callable only by the owner of the\r\n     * Amp contract.\r\n     * @param _prefix The 4 byte partition prefix the strategy applies to.\r\n     * @param _implementation The address of the implementation of the strategy hooks.\r\n     */\r\n    function setPartitionStrategy(bytes4 _prefix, address _implementation) external {\r\n        require(msg.sender == owner(), EC_56_INVALID_SENDER);\r\n        require(!_isPartitionStrategy[_prefix], EC_5E_PARTITION_PREFIX_CONFLICT);\r\n        require(_prefix != ZERO_PREFIX, EC_5F_INVALID_PARTITION_PREFIX_0);\r\n\r\n        string memory iname = PartitionUtils._getPartitionStrategyValidatorIName(_prefix);\r\n\r\n        ERC1820Client.setInterfaceImplementation(iname, _implementation);\r\n        partitionStrategies.push(_prefix);\r\n        _isPartitionStrategy[_prefix] = true;\r\n\r\n        emit PartitionStrategySet(_prefix, iname, _implementation);\r\n    }\r\n\r\n    /**\r\n     * @notice Return if a partition strategy has been reserved and has an\r\n     * implementation registered.\r\n     * @param _prefix The partition strategy identifier.\r\n     * @return \'true\' if the strategy has been registered, \'false\' if not.\r\n     */\r\n    function isPartitionStrategy(bytes4 _prefix) external view returns (bool) {\r\n        return _isPartitionStrategy[_prefix];\r\n    }\r\n\r\n    /**************************************************************************/\r\n    /*************************** INTERNAL FUNCTIONS ***************************/\r\n    /**************************************************************************/\r\n\r\n    /**************************************************************************/\r\n    /**************************** Token Transfers *****************************/\r\n\r\n    /**\r\n     * @dev Transfer tokens from a specific partition.\r\n     * @param _fromPartition Partition of the tokens to transfer.\r\n     * @param _operator The address performing the transfer.\r\n     * @param _from Token holder.\r\n     * @param _to Token recipient.\r\n     * @param _value Number of tokens to transfer.\r\n     * @param _data Information attached to the transfer. Contains the destination\r\n     * partition if a partition change is requested.\r\n     * @param _operatorData Information attached to the transfer, by the operator\r\n     * (if any).\r\n     * @return Destination partition.\r\n     */\r\n    function _transferByPartition(\r\n        bytes32 _fromPartition,\r\n        address _operator,\r\n        address _from,\r\n        address _to,\r\n        uint256 _value,\r\n        bytes memory _data,\r\n        bytes memory _operatorData\r\n    ) internal returns (bytes32) {\r\n        require(_to != address(0), EC_57_INVALID_RECEIVER);\r\n\r\n        // If the `_operator` is attempting to transfer from a different `_from`\r\n        // address, first check that they have the requisite operator or\r\n        // allowance permissions.\r\n        if (_from != _operator) {\r\n            require(\r\n                _isOperatorForPartition(_fromPartition, _operator, _from) ||\r\n                    (_value <= _allowedByPartition[_fromPartition][_from][_operator]),\r\n                EC_53_INSUFFICIENT_ALLOWANCE\r\n            );\r\n\r\n            // If the sender has an allowance for the partition, that should\r\n            // be decremented\r\n            if (_allowedByPartition[_fromPartition][_from][_operator] >= _value) {\r\n                _allowedByPartition[_fromPartition][_from][msg\r\n                    .sender] = _allowedByPartition[_fromPartition][_from][_operator].sub(\r\n                    _value\r\n                );\r\n            } else {\r\n                _allowedByPartition[_fromPartition][_from][_operator] = 0;\r\n            }\r\n        }\r\n\r\n        _callPreTransferHooks(\r\n            _fromPartition,\r\n            _operator,\r\n            _from,\r\n            _to,\r\n            _value,\r\n            _data,\r\n            _operatorData\r\n        );\r\n\r\n        require(\r\n            _balanceOfByPartition[_from][_fromPartition] >= _value,\r\n            EC_52_INSUFFICIENT_BALANCE\r\n        );\r\n\r\n        bytes32 toPartition = PartitionUtils._getDestinationPartition(\r\n            _data,\r\n            _fromPartition\r\n        );\r\n\r\n        _removeTokenFromPartition(_from, _fromPartition, _value);\r\n        _addTokenToPartition(_to, toPartition, _value);\r\n        _callPostTransferHooks(\r\n            toPartition,\r\n            _operator,\r\n            _from,\r\n            _to,\r\n            _value,\r\n            _data,\r\n            _operatorData\r\n        );\r\n\r\n        emit Transfer(_from, _to, _value);\r\n        emit TransferByPartition(\r\n            _fromPartition,\r\n            _operator,\r\n            _from,\r\n            _to,\r\n            _value,\r\n            _data,\r\n            _operatorData\r\n        );\r\n\r\n        if (toPartition != _fromPartition) {\r\n            emit ChangedPartition(_fromPartition, toPartition, _value);\r\n        }\r\n\r\n        return toPartition;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer tokens from default partitions.\r\n     * @dev Used as a helper method for ERC20 compatibility.\r\n     * @param _operator The address performing the transfer.\r\n     * @param _from Token holder.\r\n     * @param _to Token recipient.\r\n     * @param _value Number of tokens to transfer.\r\n     * @param _data Information attached to the transfer, and intended for the\r\n     * token holder (`_from`). Should contain the destination partition if\r\n     * changing partitions.\r\n     */\r\n    function _transferByDefaultPartition(\r\n        address _operator,\r\n        address _from,\r\n        address _to,\r\n        uint256 _value,\r\n        bytes memory _data\r\n    ) internal {\r\n        _transferByPartition(defaultPartition, _operator, _from, _to, _value, _data, """");\r\n    }\r\n\r\n    /**\r\n     * @dev Remove a token from a specific partition.\r\n     * @param _from Token holder.\r\n     * @param _partition Name of the partition.\r\n     * @param _value Number of tokens to transfer.\r\n     */\r\n    function _removeTokenFromPartition(\r\n        address _from,\r\n        bytes32 _partition,\r\n        uint256 _value\r\n    ) internal {\r\n        if (_value == 0) {\r\n            return;\r\n        }\r\n\r\n        _balances[_from] = _balances[_from].sub(_value);\r\n\r\n        _balanceOfByPartition[_from][_partition] = _balanceOfByPartition[_from][_partition]\r\n            .sub(_value);\r\n        totalSupplyByPartition[_partition] = totalSupplyByPartition[_partition].sub(\r\n            _value\r\n        );\r\n\r\n        // If the total supply is zero, finds and deletes the partition.\r\n        // Do not delete the _defaultPartition from totalPartitions.\r\n        if (totalSupplyByPartition[_partition] == 0 && _partition != defaultPartition) {\r\n            _removePartitionFromTotalPartitions(_partition);\r\n        }\r\n\r\n        // If the balance of the TokenHolder\'s partition is zero, finds and\r\n        // deletes the partition.\r\n        if (_balanceOfByPartition[_from][_partition] == 0) {\r\n            uint256 index = _indexOfPartitionsOf[_from][_partition];\r\n\r\n            if (index == 0) {\r\n                return;\r\n            }\r\n\r\n            // move the last item into the index being vacated\r\n            bytes32 lastValue = _partitionsOf[_from][_partitionsOf[_from].length - 1];\r\n            _partitionsOf[_from][index - 1] = lastValue; // adjust for 1-based indexing\r\n            _indexOfPartitionsOf[_from][lastValue] = index;\r\n\r\n            _partitionsOf[_from].pop();\r\n            _indexOfPartitionsOf[_from][_partition] = 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Add a token to a specific partition.\r\n     * @param _to Token recipient.\r\n     * @param _partition Name of the partition.\r\n     * @param _value Number of tokens to transfer.\r\n     */\r\n    function _addTokenToPartition(\r\n        address _to,\r\n        bytes32 _partition,\r\n        uint256 _value\r\n    ) internal {\r\n        if (_value == 0) {\r\n            return;\r\n        }\r\n\r\n        _balances[_to] = _balances[_to].add(_value);\r\n\r\n        if (_indexOfPartitionsOf[_to][_partition] == 0) {\r\n            _partitionsOf[_to].push(_partition);\r\n            _indexOfPartitionsOf[_to][_partition] = _partitionsOf[_to].length;\r\n        }\r\n        _balanceOfByPartition[_to][_partition] = _balanceOfByPartition[_to][_partition]\r\n            .add(_value);\r\n\r\n        if (_indexOfTotalPartitions[_partition] == 0) {\r\n            _addPartitionToTotalPartitions(_partition);\r\n        }\r\n        totalSupplyByPartition[_partition] = totalSupplyByPartition[_partition].add(\r\n            _value\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Add a partition to the total partitions collection.\r\n     * @param _partition Name of the partition.\r\n     */\r\n    function _addPartitionToTotalPartitions(bytes32 _partition) internal {\r\n        _totalPartitions.push(_partition);\r\n        _indexOfTotalPartitions[_partition] = _totalPartitions.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove a partition to the total partitions collection.\r\n     * @param _partition Name of the partition.\r\n     */\r\n    function _removePartitionFromTotalPartitions(bytes32 _partition) internal {\r\n        uint256 index = _indexOfTotalPartitions[_partition];\r\n\r\n        if (index == 0) {\r\n            return;\r\n        }\r\n\r\n        // move the last item into the index being vacated\r\n        bytes32 lastValue = _totalPartitions[_totalPartitions.length - 1];\r\n        _totalPartitions[index - 1] = lastValue; // adjust for 1-based indexing\r\n        _indexOfTotalPartitions[lastValue] = index;\r\n\r\n        _totalPartitions.pop();\r\n        _indexOfTotalPartitions[_partition] = 0;\r\n    }\r\n\r\n    /**************************************************************************/\r\n    /********************************* Hooks **********************************/\r\n    /**\r\n     * @notice Check for and call the \'AmpTokensSender\' hook on the sender address\r\n     * (`_from`), and, if `_fromPartition` is within the scope of a strategy,\r\n     * check for and call the \'AmpPartitionStrategy.tokensFromPartitionToTransfer\'\r\n     * hook for the strategy.\r\n     * @param _fromPartition Name of the partition to transfer tokens from.\r\n     * @param _operator Address which triggered the balance decrease (through\r\n     * transfer).\r\n     * @param _from Token holder.\r\n     * @param _to Token recipient for a transfer.\r\n     * @param _value Number of tokens the token holder balance is decreased by.\r\n     * @param _data Extra information, pertaining to the `_from` address.\r\n     * @param _operatorData Extra information, attached by the operator (if any).\r\n     */\r\n    function _callPreTransferHooks(\r\n        bytes32 _fromPartition,\r\n        address _operator,\r\n        address _from,\r\n        address _to,\r\n        uint256 _value,\r\n        bytes memory _data,\r\n        bytes memory _operatorData\r\n    ) internal {\r\n        address senderImplementation;\r\n        senderImplementation = interfaceAddr(_from, AMP_TOKENS_SENDER);\r\n        if (senderImplementation != address(0)) {\r\n            IAmpTokensSender(senderImplementation).tokensToTransfer(\r\n                msg.sig,\r\n                _fromPartition,\r\n                _operator,\r\n                _from,\r\n                _to,\r\n                _value,\r\n                _data,\r\n                _operatorData\r\n            );\r\n        }\r\n\r\n        // Used to ensure that hooks implemented by a collateral manager to validate\r\n        // transfers from it\'s owned partitions are called\r\n        bytes4 fromPartitionPrefix = PartitionUtils._getPartitionPrefix(_fromPartition);\r\n        if (_isPartitionStrategy[fromPartitionPrefix]) {\r\n            address fromPartitionValidatorImplementation;\r\n            fromPartitionValidatorImplementation = interfaceAddr(\r\n                address(this),\r\n                PartitionUtils._getPartitionStrategyValidatorIName(fromPartitionPrefix)\r\n            );\r\n            if (fromPartitionValidatorImplementation != address(0)) {\r\n                IAmpPartitionStrategyValidator(fromPartitionValidatorImplementation)\r\n                    .tokensFromPartitionToValidate(\r\n                    msg.sig,\r\n                    _fromPartition,\r\n                    _operator,\r\n                    _from,\r\n                    _to,\r\n                    _value,\r\n                    _data,\r\n                    _operatorData\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Check for \'AmpTokensRecipient\' hook on the recipient and call it.\r\n     * @param _toPartition Name of the partition the tokens were transferred to.\r\n     * @param _operator Address which triggered the balance increase (through\r\n     * transfer or mint).\r\n     * @param _from Token holder for a transfer (0x when mint).\r\n     * @param _to Token recipient.\r\n     * @param _value Number of tokens the recipient balance is increased by.\r\n     * @param _data Extra information related to the token holder (`_from`).\r\n     * @param _operatorData Extra information attached by the operator (if any).\r\n     */\r\n    function _callPostTransferHooks(\r\n        bytes32 _toPartition,\r\n        address _operator,\r\n        address _from,\r\n        address _to,\r\n        uint256 _value,\r\n        bytes memory _data,\r\n        bytes memory _operatorData\r\n    ) internal {\r\n        bytes4 toPartitionPrefix = PartitionUtils._getPartitionPrefix(_toPartition);\r\n        if (_isPartitionStrategy[toPartitionPrefix]) {\r\n            address partitionManagerImplementation;\r\n            partitionManagerImplementation = interfaceAddr(\r\n                address(this),\r\n                PartitionUtils._getPartitionStrategyValidatorIName(toPartitionPrefix)\r\n            );\r\n            if (partitionManagerImplementation != address(0)) {\r\n                IAmpPartitionStrategyValidator(partitionManagerImplementation)\r\n                    .tokensToPartitionToValidate(\r\n                    msg.sig,\r\n                    _toPartition,\r\n                    _operator,\r\n                    _from,\r\n                    _to,\r\n                    _value,\r\n                    _data,\r\n                    _operatorData\r\n                );\r\n            }\r\n        } else {\r\n            require(toPartitionPrefix == ZERO_PREFIX, EC_5D_PARTITION_RESERVED);\r\n        }\r\n\r\n        address recipientImplementation;\r\n        recipientImplementation = interfaceAddr(_to, AMP_TOKENS_RECIPIENT);\r\n\r\n        if (recipientImplementation != address(0)) {\r\n            IAmpTokensRecipient(recipientImplementation).tokensReceived(\r\n                msg.sig,\r\n                _toPartition,\r\n                _operator,\r\n                _from,\r\n                _to,\r\n                _value,\r\n                _data,\r\n                _operatorData\r\n            );\r\n        }\r\n    }\r\n\r\n    /**************************************************************************/\r\n    /******************************* Allowance ********************************/\r\n    /**\r\n     * @notice Approve the `_spender` address to spend the specified amount of\r\n     * tokens in `_partition` on behalf of \'msg.sender\'.\r\n     * @param _partition Name of the partition.\r\n     * @param _tokenHolder Owner of the tokens.\r\n     * @param _spender The address which will spend the tokens.\r\n     * @param _amount The amount of tokens to be tokens.\r\n     */\r\n    function _approveByPartition(\r\n        bytes32 _partition,\r\n        address _tokenHolder,\r\n        address _spender,\r\n        uint256 _amount\r\n    ) internal {\r\n        require(_tokenHolder != address(0), EC_56_INVALID_SENDER);\r\n        require(_spender != address(0), EC_58_INVALID_OPERATOR);\r\n\r\n        _allowedByPartition[_partition][_tokenHolder][_spender] = _amount;\r\n        emit ApprovalByPartition(_partition, _tokenHolder, _spender, _amount);\r\n\r\n        if (_partition == defaultPartition) {\r\n            emit Approval(_tokenHolder, _spender, _amount);\r\n        }\r\n    }\r\n\r\n    /**************************************************************************/\r\n    /************************** Operator Information **************************/\r\n    /**\r\n     * @dev Indicate whether the operator address is an operator of the\r\n     * tokenHolder address. An operator in this case is an operator across all\r\n     * partitions of the `msg.sender` address.\r\n     * @param _operator Address which may be an operator of \'_tokenHolder\'.\r\n     * @param _tokenHolder Address of a token holder which may have the \'_operator\'\r\n     * address as an operator.\r\n     * @return \'true\' if `_operator` is an operator of `_tokenHolder` and \'false\'\r\n     * otherwise.\r\n     */\r\n    function _isOperator(address _operator, address _tokenHolder)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return (_operator == _tokenHolder ||\r\n            _authorizedOperator[_tokenHolder][_operator]);\r\n    }\r\n\r\n    /**\r\n     * @dev Indicate whether the operator address is an operator of the\r\n     * tokenHolder address for the given partition.\r\n     * @param _partition Name of the partition.\r\n     * @param _operator Address which may be an operator of tokenHolder for the\r\n     * given partition.\r\n     * @param _tokenHolder Address of a token holder which may have the operator\r\n     * address as an operator for the given partition.\r\n     * @return \'true\' if \'operator\' is an operator of \'tokenHolder\' for partition\r\n     * `_partition` and \'false\' otherwise.\r\n     */\r\n    function _isOperatorForPartition(\r\n        bytes32 _partition,\r\n        address _operator,\r\n        address _tokenHolder\r\n    ) internal view returns (bool) {\r\n        return (_isOperator(_operator, _tokenHolder) ||\r\n            _authorizedOperatorByPartition[_tokenHolder][_partition][_operator] ||\r\n            _callPartitionStrategyOperatorHook(_partition, _operator, _tokenHolder));\r\n    }\r\n\r\n    /**\r\n     * @notice Check if the `_partition` is within the scope of a strategy, and\r\n     * call it\'s isOperatorForPartitionScope hook if so.\r\n     * @dev This allows implicit granting of operatorByPartition permissions\r\n     * based on the partition being used being of a strategy.\r\n     * @param _partition The partition to check.\r\n     * @param _operator The address to check if is an operator for `_tokenHolder`.\r\n     * @param _tokenHolder The address to validate that `_operator` is an\r\n     * operator for.\r\n     */\r\n    function _callPartitionStrategyOperatorHook(\r\n        bytes32 _partition,\r\n        address _operator,\r\n        address _tokenHolder\r\n    ) internal view returns (bool) {\r\n        bytes4 prefix = PartitionUtils._getPartitionPrefix(_partition);\r\n\r\n        if (!_isPartitionStrategy[prefix]) {\r\n            return false;\r\n        }\r\n\r\n        address strategyValidatorImplementation;\r\n        strategyValidatorImplementation = interfaceAddr(\r\n            address(this),\r\n            PartitionUtils._getPartitionStrategyValidatorIName(prefix)\r\n        );\r\n        if (strategyValidatorImplementation != address(0)) {\r\n            return\r\n                IAmpPartitionStrategyValidator(strategyValidatorImplementation)\r\n                    .isOperatorForPartitionScope(_partition, _operator, _tokenHolder);\r\n        }\r\n\r\n        // Not a partition format that imbues special operator rules\r\n        return false;\r\n    }\r\n\r\n    /**************************************************************************/\r\n    /******************************** Minting *********************************/\r\n    /**\r\n     * @notice Perform the minting of tokens.\r\n     * @dev The tokens will be minted on behalf of the `_to` address, and will be\r\n     * minted to the address\'s default partition.\r\n     * @param _operator Address which triggered the issuance.\r\n     * @param _to Token recipient.\r\n     * @param _value Number of tokens issued.\r\n     */\r\n    function _mint(\r\n        address _operator,\r\n        address _to,\r\n        uint256 _value\r\n    ) internal {\r\n        require(_to != address(0), EC_57_INVALID_RECEIVER);\r\n\r\n        _totalSupply = _totalSupply.add(_value);\r\n        _addTokenToPartition(_to, defaultPartition, _value);\r\n        _callPostTransferHooks(\r\n            defaultPartition,\r\n            _operator,\r\n            address(0),\r\n            _to,\r\n            _value,\r\n            """",\r\n            """"\r\n        );\r\n\r\n        emit Minted(_operator, _to, _value, """");\r\n        emit Transfer(address(0), _to, _value);\r\n        emit TransferByPartition(bytes32(0), _operator, address(0), _to, _value, """", """");\r\n    }\r\n}', 'ABI': '[{""inputs"":[{""internalType"":""address"",""name"":""_swapTokenAddress_"",""type"":""address""},{""internalType"":""string"",""name"":""_name_"",""type"":""string""},{""internalType"":""string"",""name"":""_symbol_"",""type"":""string""}],""stateMutability"":""nonpayable"",""type"":""constructor""},{""anonymous"":false,""inputs"":[{""indexed"":true,""internalType"":""address"",""name"":""owner"",""type"":""address""},{""indexed"":true,""internalType"":""address"",""name"":""spender"",""type"":""address""},{""indexed"":false,""internalType"":""uint256"",""name"":""value"",""type"":""uint256""}],""name"":""Approval"",""type"":""event""},{""anonymous"":false,""inputs"":[{""indexed"":true,""internalType"":""bytes32"",""name"":""partition"",""type"":""bytes32""},{""indexed"":true,""internalType"":""address"",""name"":""owner"",""type"":""address""},{""indexed"":true,""internalType"":""address"",""name"":""spender"",""type"":""address""},{""indexed"":false,""internalType"":""uint256"",""name"":""value"",""type"":""uint256""}],""name"":""ApprovalByPartition"",""type"":""event""},{""anonymous"":false,""inputs"":[{""indexed"":true,""internalType"":""address"",""name"":""operator"",""type"":""address""},{""indexed"":true,""internalType"":""address"",""name"":""tokenHolder"",""type"":""address""}],""name"":""AuthorizedOperator"",""type"":""event""},{""anonymous"":false,""inputs"":[{""indexed"":true,""internalType"":""bytes32"",""name"":""partition"",""type"":""bytes32""},{""indexed"":true,""internalType"":""address"",""name"":""operator"",""type"":""address""},{""indexed"":true,""internalType"":""address"",""name"":""tokenHolder"",""type"":""address""}],""name"":""AuthorizedOperatorByPartition"",""type"":""event""},{""anonymous"":false,""inputs"":[{""indexed"":true,""internalType"":""bytes32"",""name"":""fromPartition"",""type"":""bytes32""},{""indexed"":true,""internalType"":""bytes32"",""name"":""toPartition"",""type"":""bytes32""},{""indexed"":false,""internalType"":""uint256"",""name"":""value"",""type"":""uint256""}],""name"":""ChangedPartition"",""type"":""event""},{""anonymous"":false,""inputs"":[{""indexed"":false,""internalType"":""address"",""name"":""collateralManager"",""type"":""address""}],""name"":""CollateralManagerRegistered"",""type"":""event""},{""anonymous"":false,""inputs"":[{""indexed"":true,""internalType"":""address"",""name"":""operator"",""type"":""address""},{""indexed"":true,""internalType"":""address"",""name"":""to"",""type"":""address""},{""indexed"":false,""internalType"":""uint256"",""name"":""value"",""type"":""uint256""},{""indexed"":false,""internalType"":""bytes"",""name"":""data"",""type"":""bytes""}],""name"":""Minted"",""type"":""event""},{""anonymous"":false,""inputs"":[{""indexed"":true,""internalType"":""address"",""name"":""oldValue"",""type"":""address""},{""indexed"":true,""internalType"":""address"",""name"":""newValue"",""type"":""address""}],""name"":""OwnerUpdate"",""type"":""event""},{""anonymous"":false,""inputs"":[{""indexed"":true,""internalType"":""address"",""name"":""authorizedAddress"",""type"":""address""}],""name"":""OwnershipTransferAuthorization"",""type"":""event""},{""anonymous"":false,""inputs"":[{""indexed"":false,""internalType"":""bytes4"",""name"":""flag"",""type"":""bytes4""},{""indexed"":false,""internalType"":""string"",""name"":""name"",""type"":""string""},{""indexed"":true,""internalType"":""address"",""name"":""implementation"",""type"":""address""}],""name"":""PartitionStrategySet"",""type"":""event""},{""anonymous"":false,""inputs"":[{""indexed"":true,""internalType"":""address"",""name"":""operator"",""type"":""address""},{""indexed"":true,""internalType"":""address"",""name"":""tokenHolder"",""type"":""address""}],""name"":""RevokedOperator"",""type"":""event""},{""anonymous"":false,""inputs"":[{""indexed"":true,""internalType"":""bytes32"",""name"":""partition"",""type"":""bytes32""},{""indexed"":true,""internalType"":""address"",""name"":""operator"",""type"":""address""},{""indexed"":true,""internalType"":""address"",""name"":""tokenHolder"",""type"":""address""}],""name"":""RevokedOperatorByPartition"",""type"":""event""},{""anonymous"":false,""inputs"":[{""indexed"":true,""internalType"":""address"",""name"":""operator"",""type"":""address""},{""indexed"":true,""internalType"":""address"",""name"":""from"",""type"":""address""},{""indexed"":false,""internalType"":""uint256"",""name"":""value"",""type"":""uint256""}],""name"":""Swap"",""type"":""event""},{""anonymous"":false,""inputs"":[{""indexed"":true,""internalType"":""address"",""name"":""from"",""type"":""address""},{""indexed"":true,""internalType"":""address"",""name"":""to"",""type"":""address""},{""indexed"":false,""internalType"":""uint256"",""name"":""value"",""type"":""uint256""}],""name"":""Transfer"",""type"":""event""},{""anonymous"":false,""inputs"":[{""indexed"":true,""internalType"":""bytes32"",""name"":""fromPartition"",""type"":""bytes32""},{""indexed"":false,""internalType"":""address"",""name"":""operator"",""type"":""address""},{""indexed"":true,""internalType"":""address"",""name"":""from"",""type"":""address""},{""indexed"":true,""internalType"":""address"",""name"":""to"",""type"":""address""},{""indexed"":false,""internalType"":""uint256"",""name"":""value"",""type"":""uint256""},{""indexed"":false,""internalType"":""bytes"",""name"":""data"",""type"":""bytes""},{""indexed"":false,""internalType"":""bytes"",""name"":""operatorData"",""type"":""bytes""}],""name"":""TransferByPartition"",""type"":""event""},{""inputs"":[{""internalType"":""address"",""name"":""_owner"",""type"":""address""},{""internalType"":""address"",""name"":""_spender"",""type"":""address""}],""name"":""allowance"",""outputs"":[{""internalType"":""uint256"",""name"":"""",""type"":""uint256""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[{""internalType"":""bytes32"",""name"":""_partition"",""type"":""bytes32""},{""internalType"":""address"",""name"":""_owner"",""type"":""address""},{""internalType"":""address"",""name"":""_spender"",""type"":""address""}],""name"":""allowanceByPartition"",""outputs"":[{""internalType"":""uint256"",""name"":"""",""type"":""uint256""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[{""internalType"":""address"",""name"":""_spender"",""type"":""address""},{""internalType"":""uint256"",""name"":""_value"",""type"":""uint256""}],""name"":""approve"",""outputs"":[{""internalType"":""bool"",""name"":"""",""type"":""bool""}],""stateMutability"":""nonpayable"",""type"":""function""},{""inputs"":[{""internalType"":""bytes32"",""name"":""_partition"",""type"":""bytes32""},{""internalType"":""address"",""name"":""_spender"",""type"":""address""},{""internalType"":""uint256"",""name"":""_value"",""type"":""uint256""}],""name"":""approveByPartition"",""outputs"":[{""internalType"":""bool"",""name"":"""",""type"":""bool""}],""stateMutability"":""nonpayable"",""type"":""function""},{""inputs"":[],""name"":""assumeOwnership"",""outputs"":[],""stateMutability"":""nonpayable"",""type"":""function""},{""inputs"":[{""internalType"":""address"",""name"":""_operator"",""type"":""address""}],""name"":""authorizeOperator"",""outputs"":[],""stateMutability"":""nonpayable"",""type"":""function""},{""inputs"":[{""internalType"":""bytes32"",""name"":""_partition"",""type"":""bytes32""},{""internalType"":""address"",""name"":""_operator"",""type"":""address""}],""name"":""authorizeOperatorByPartition"",""outputs"":[],""stateMutability"":""nonpayable"",""type"":""function""},{""inputs"":[{""internalType"":""address"",""name"":""_authorizedAddress"",""type"":""address""}],""name"":""authorizeOwnershipTransfer"",""outputs"":[],""stateMutability"":""nonpayable"",""type"":""function""},{""inputs"":[],""name"":""authorizedNewOwner"",""outputs"":[{""internalType"":""address"",""name"":"""",""type"":""address""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[{""internalType"":""address"",""name"":""_tokenHolder"",""type"":""address""}],""name"":""balanceOf"",""outputs"":[{""internalType"":""uint256"",""name"":"""",""type"":""uint256""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[{""internalType"":""bytes32"",""name"":""_partition"",""type"":""bytes32""},{""internalType"":""address"",""name"":""_tokenHolder"",""type"":""address""}],""name"":""balanceOfByPartition"",""outputs"":[{""internalType"":""uint256"",""name"":"""",""type"":""uint256""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[{""internalType"":""bytes32"",""name"":""_interfaceHash"",""type"":""bytes32""},{""internalType"":""address"",""name"":"""",""type"":""address""}],""name"":""canImplementInterfaceForAddress"",""outputs"":[{""internalType"":""bytes32"",""name"":"""",""type"":""bytes32""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[{""internalType"":""uint256"",""name"":"""",""type"":""uint256""}],""name"":""collateralManagers"",""outputs"":[{""internalType"":""address"",""name"":"""",""type"":""address""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[],""name"":""decimals"",""outputs"":[{""internalType"":""uint8"",""name"":"""",""type"":""uint8""}],""stateMutability"":""pure"",""type"":""function""},{""inputs"":[{""internalType"":""address"",""name"":""_spender"",""type"":""address""},{""internalType"":""uint256"",""name"":""_subtractedValue"",""type"":""uint256""}],""name"":""decreaseAllowance"",""outputs"":[{""internalType"":""bool"",""name"":"""",""type"":""bool""}],""stateMutability"":""nonpayable"",""type"":""function""},{""inputs"":[{""internalType"":""bytes32"",""name"":""_partition"",""type"":""bytes32""},{""internalType"":""address"",""name"":""_spender"",""type"":""address""},{""internalType"":""uint256"",""name"":""_subtractedValue"",""type"":""uint256""}],""name"":""decreaseAllowanceByPartition"",""outputs"":[{""internalType"":""bool"",""name"":"""",""type"":""bool""}],""stateMutability"":""nonpayable"",""type"":""function""},{""inputs"":[],""name"":""defaultPartition"",""outputs"":[{""internalType"":""bytes32"",""name"":"""",""type"":""bytes32""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[],""name"":""granularity"",""outputs"":[{""internalType"":""uint256"",""name"":"""",""type"":""uint256""}],""stateMutability"":""pure"",""type"":""function""},{""inputs"":[{""internalType"":""address"",""name"":""_spender"",""type"":""address""},{""internalType"":""uint256"",""name"":""_addedValue"",""type"":""uint256""}],""name"":""increaseAllowance"",""outputs"":[{""internalType"":""bool"",""name"":"""",""type"":""bool""}],""stateMutability"":""nonpayable"",""type"":""function""},{""inputs"":[{""internalType"":""bytes32"",""name"":""_partition"",""type"":""bytes32""},{""internalType"":""address"",""name"":""_spender"",""type"":""address""},{""internalType"":""uint256"",""name"":""_addedValue"",""type"":""uint256""}],""name"":""increaseAllowanceByPartition"",""outputs"":[{""internalType"":""bool"",""name"":"""",""type"":""bool""}],""stateMutability"":""nonpayable"",""type"":""function""},{""inputs"":[{""internalType"":""address"",""name"":""_collateralManager"",""type"":""address""}],""name"":""isCollateralManager"",""outputs"":[{""internalType"":""bool"",""name"":"""",""type"":""bool""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[{""internalType"":""address"",""name"":""_operator"",""type"":""address""},{""internalType"":""address"",""name"":""_tokenHolder"",""type"":""address""}],""name"":""isOperator"",""outputs"":[{""internalType"":""bool"",""name"":"""",""type"":""bool""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[{""internalType"":""bytes32"",""name"":""_partition"",""type"":""bytes32""},{""internalType"":""address"",""name"":""_operator"",""type"":""address""},{""internalType"":""address"",""name"":""_collateralManager"",""type"":""address""}],""name"":""isOperatorForCollateralManager"",""outputs"":[{""internalType"":""bool"",""name"":"""",""type"":""bool""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[{""internalType"":""bytes32"",""name"":""_partition"",""type"":""bytes32""},{""internalType"":""address"",""name"":""_operator"",""type"":""address""},{""internalType"":""address"",""name"":""_tokenHolder"",""type"":""address""}],""name"":""isOperatorForPartition"",""outputs"":[{""internalType"":""bool"",""name"":"""",""type"":""bool""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[{""internalType"":""bytes4"",""name"":""_prefix"",""type"":""bytes4""}],""name"":""isPartitionStrategy"",""outputs"":[{""internalType"":""bool"",""name"":"""",""type"":""bool""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[],""name"":""name"",""outputs"":[{""internalType"":""string"",""name"":"""",""type"":""string""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[],""name"":""owner"",""outputs"":[{""internalType"":""address"",""name"":"""",""type"":""address""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[{""internalType"":""uint256"",""name"":"""",""type"":""uint256""}],""name"":""partitionStrategies"",""outputs"":[{""internalType"":""bytes4"",""name"":"""",""type"":""bytes4""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[{""internalType"":""address"",""name"":""_tokenHolder"",""type"":""address""}],""name"":""partitionsOf"",""outputs"":[{""internalType"":""bytes32[]"",""name"":"""",""type"":""bytes32[]""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[],""name"":""registerCollateralManager"",""outputs"":[],""stateMutability"":""nonpayable"",""type"":""function""},{""inputs"":[{""internalType"":""address"",""name"":""_operator"",""type"":""address""}],""name"":""revokeOperator"",""outputs"":[],""stateMutability"":""nonpayable"",""type"":""function""},{""inputs"":[{""internalType"":""bytes32"",""name"":""_partition"",""type"":""bytes32""},{""internalType"":""address"",""name"":""_operator"",""type"":""address""}],""name"":""revokeOperatorByPartition"",""outputs"":[],""stateMutability"":""nonpayable"",""type"":""function""},{""inputs"":[{""internalType"":""bytes4"",""name"":""_prefix"",""type"":""bytes4""},{""internalType"":""address"",""name"":""_implementation"",""type"":""address""}],""name"":""setPartitionStrategy"",""outputs"":[],""stateMutability"":""nonpayable"",""type"":""function""},{""inputs"":[{""internalType"":""address"",""name"":""_from"",""type"":""address""}],""name"":""swap"",""outputs"":[],""stateMutability"":""nonpayable"",""type"":""function""},{""inputs"":[],""name"":""swapToken"",""outputs"":[{""internalType"":""contract ISwapToken"",""name"":"""",""type"":""address""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[],""name"":""swapTokenGraveyard"",""outputs"":[{""internalType"":""address"",""name"":"""",""type"":""address""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[],""name"":""symbol"",""outputs"":[{""internalType"":""string"",""name"":"""",""type"":""string""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[],""name"":""totalPartitions"",""outputs"":[{""internalType"":""bytes32[]"",""name"":"""",""type"":""bytes32[]""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[],""name"":""totalSupply"",""outputs"":[{""internalType"":""uint256"",""name"":"""",""type"":""uint256""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[{""internalType"":""bytes32"",""name"":"""",""type"":""bytes32""}],""name"":""totalSupplyByPartition"",""outputs"":[{""internalType"":""uint256"",""name"":"""",""type"":""uint256""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[{""internalType"":""address"",""name"":""_to"",""type"":""address""},{""internalType"":""uint256"",""name"":""_value"",""type"":""uint256""}],""name"":""transfer"",""outputs"":[{""internalType"":""bool"",""name"":"""",""type"":""bool""}],""stateMutability"":""nonpayable"",""type"":""function""},{""inputs"":[{""internalType"":""bytes32"",""name"":""_partition"",""type"":""bytes32""},{""internalType"":""address"",""name"":""_from"",""type"":""address""},{""internalType"":""address"",""name"":""_to"",""type"":""address""},{""internalType"":""uint256"",""name"":""_value"",""type"":""uint256""},{""internalType"":""bytes"",""name"":""_data"",""type"":""bytes""},{""internalType"":""bytes"",""name"":""_operatorData"",""type"":""bytes""}],""name"":""transferByPartition"",""outputs"":[{""internalType"":""bytes32"",""name"":"""",""type"":""bytes32""}],""stateMutability"":""nonpayable"",""type"":""function""},{""inputs"":[{""internalType"":""address"",""name"":""_from"",""type"":""address""},{""internalType"":""address"",""name"":""_to"",""type"":""address""},{""internalType"":""uint256"",""name"":""_value"",""type"":""uint256""}],""name"":""transferFrom"",""outputs"":[{""internalType"":""bool"",""name"":"""",""type"":""bool""}],""stateMutability"":""nonpayable"",""type"":""function""}]', 'ContractName': 'Amp', 'CompilerVersion': 'v0.6.10+commit.00c0fcaf', 'OptimizationUsed': '1', 'Runs': '200', 'ConstructorArguments': '0000000000000000000000004a57e687b9126435a9b19e4a802113e266adebde000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000003416d7000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003414d500000000000000000000000000000000000000000000000000000000000', 'EVMVersion': 'Default', 'Library': '', 'LicenseType': 'MIT', 'Proxy': '0', 'Implementation': '', 'SwarmSource': 'ipfs://46f1197cc0a6e3d6399ed22c3480b4059302d3180614e1c23cf41dc5ac022197'}]"
1,OK,"[{'SourceCode': '', 'ABI': 'Contract source code not verified', 'ContractName': '', 'CompilerVersion': '', 'OptimizationUsed': '', 'Runs': '', 'ConstructorArguments': '', 'EVMVersion': 'Default', 'Library': '', 'LicenseType': 'Unknown', 'Proxy': '0', 'Implementation': '', 'SwarmSource': ''}]"
